<!DOCTYPE html>
<html>
<head>
	<title>Multiple Objects</title>
	<style type="text/css">
		@import url("https://webglfundamentals.org/webgl/resources/webgl-tutorials.css");
		body {
		  margin: 0;
		}
		canvas {
		  width: 100vw;
		  height: 100vh;
		  display: block;
		}
	</style>
</head>
<body>
<canvas id="canvas"></canvas>
<!-- vertex shader -->
<script  id="3d-vertex-shader" type="x-shader/x-vertex">
attribute vec4 a_position;
attribute vec4 a_color;

uniform mat4 u_matrix;

varying vec4 v_color;

void main() {
  // Multiply the position by the matrix.
  gl_Position = u_matrix * a_position;

  // Pass the color to the fragment shader.
  v_color = a_color;
}
</script>
<!-- fragment shader -->
<script  id="3d-fragment-shader" type="x-shader/x-fragment">
precision mediump float;

// Passed in from the vertex shader.
varying vec4 v_color;

uniform vec4 u_colorMult;

void main() {
   gl_FragColor = v_color * u_colorMult;
}
</script><!--
for most samples webgl-utils only provides shader compiling/linking and
canvas resizing because why clutter the examples with code that's the same in every sample.
See http://webglfundamentals.org/webgl/lessons/webgl-boilerplate.html
and http://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
for webgl-utils, m3, m4, and webgl-lessons-ui.
-->
<script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
<script src="https://webglfundamentals.org/webgl/resources/m4.js"></script>
<script src="https://webglfundamentals.org/webgl/resources/primitives.js"></script>

<script type="text/javascript">
	// WebGL - Multiple Objects - Manual
	// from https://webglfundamentals.org/webgl/webgl-multiple-objects-manual.html

	"use strict";

	const red = [1, 0, 0, 1];
	const green = [0, 1, 0, 1];
	const blue = [0.3, 0.3, 1, 1];
	const yellow = [1, 1, 0, 1];
	const magneta = [1, 0, 1, 1];
	const black = [0.1, 0.3, 0.2, .3];

	var objects = [];

	var cameraPosition = [0, 0, 70];
	var target = [0, 0, 0];
	var up = [0, 100, 0];

	function degToRad(d) {
	    return d * Math.PI / 180;
	};

	function vecAdd(v1,v2){
		var resV = [];
		for (var i = 0; i < v1.length; i++) {
			resV[i] = v1[i]+v2[i];
		}
		return resV;
	}

	function vecMult(v1,v2){
		var resV = [];
		for (var i = 0; i < v1.length; i++) {
			resV[i] = v1[i]*v2[i];
		}
		return resV;
	}

	function mult(v1,scalar) {
		var resV = [];
		for (var i = 0; i < v1.length; i++) {
			resV[i] = v1[i]*scalar;
		}
		return resV;
	}

	var createPlane = function(gl,programInfo,location) {
		var position = location;
		position[0] = 50;
		position[2] = 20;
		var orientation=[0,0,0];
		var size=[8.5,8.5,.1];
		var speed=[0,0,0];
		var orientationChangeRate=[0,0,0];
		var sizeChangeRate=[1,1,1];
		var worldSize=[100,140,180];
		var scaleLimit=[10,10,10];

		return new WebGlObject(gl,
			programInfo,
			primitives.createCubeVertices(20),
			black,
			position,
			orientation,
			size,
			speed,
			orientationChangeRate,
			sizeChangeRate,
			worldSize,
			scaleLimit);
	}

	var createCube = function(gl,programInfo,location) {
		var position = location;
		var orientation=[0,0,0];
		var size=[1,1,1];
		var speed=[0,0,0];
		var orientationChangeRate=[1,1,0];
		var sizeChangeRate=[1,1,1];
		var worldSize=[100,140,80];
		var scaleLimit=[10,10,10];

		return new WebGlObject(gl,
			programInfo,
			primitives.createCubeVertices(20),
			red,
			position,
			orientation,
			size,
			speed,
			orientationChangeRate,
			sizeChangeRate,
			worldSize,
			scaleLimit);
	}

	var createPyramid = function(gl,programInfo,location) {
		// TODO: Translation?
		var position = location;
		var orientation=[0,0,0];
		var size=[1,1,1];
		var speed=[0,0,0];
		var orientationChangeRate=[0,0,0];
		var sizeChangeRate=[1,1,1];
		var worldSize=[100,140,80];
		var scaleLimit=[2,2,2];

		return new WebGlObject(gl, 
			programInfo,
			primitives.createTruncatedConeVertices(10, 0, 20, 3, 1, true, true),
			yellow,
			position,
			orientation,
			size,
			speed,
			orientationChangeRate,
			sizeChangeRate,
			worldSize,
			scaleLimit);
	}

	var createCylinder = function(gl,programInfo,location) {
		var position = location;
		var orientation=[0,0,0];
		var size=[1,1,1];
		var speed=[0,0,0];
		var orientationChangeRate=[0,0,0];
		var sizeChangeRate=[1.001,1.001,1.001];
		var worldSize=[100,140,80];
		var scaleLimit=[2,2,2];

		return new WebGlObject(gl, 
			programInfo,
			primitives.createTruncatedConeVertices(10, 10, 20, 20, 1, true, true),
			blue,
			position,
			orientation,
			size,
			speed,
			orientationChangeRate,
			sizeChangeRate,
			worldSize,
			scaleLimit);
	}

	var createCone = function(gl,programInfo,location) {
		var position = location;
		var orientation=[0,0,0];
		var size=[1,1,1];
		var speed=[0,0,0];
		var orientationChangeRate=[0,0,0];
		var sizeChangeRate=[1.001,1.002,1.003];
		var worldSize=[100,140,80];
		var scaleLimit=[2,2,2];

		return new WebGlObject(gl, 
			programInfo,
			primitives.createTruncatedConeVertices(10, 0, 20, 20, 1, true, true),
			magneta,
			position,
			orientation,
			size,
			speed,
			orientationChangeRate,
			sizeChangeRate,
			worldSize,
			scaleLimit);
	}

	var createSphere = function(gl,programInfo,location) {
		var position = location;
		var orientation=[0,0,0];
		var size=[1,1,1];
		var speed=[10,0,0];
		var orientationChangeRate=[0,0,0];
		var sizeChangeRate=[1,1,1];
		var worldSize=[100,140,80];
		var scaleLimit=[10,10,10];

		return new WebGlObject(gl,
			programInfo,
			primitives.createSphereVertices(10, 10, 10),
			green,
			position,
			orientation,
			size,
			speed,
			orientationChangeRate,
			sizeChangeRate,
			worldSize,
			scaleLimit);
	}

	var createObjects = function(gl,programInfo){
		const locCenter = [0,70,0];
		const locTopRight = [80,110,0];
		const locTopLeft = [20,110,0];
		const locBotRight = [80,30,0];
		const locBotLeft = [20,30,0];

		var plane = createPlane(gl,programInfo,locCenter);

		var cube = createCube(gl,programInfo,locTopLeft);

		var pyramid = createPyramid(gl,programInfo,locTopRight);

		var cylinder = createCylinder(gl,programInfo,locBotLeft);

		var cone = createCone(gl,programInfo,locBotRight);

		var sphere = createSphere(gl,programInfo,locCenter);

		var obj  = [plane, cube, pyramid, cylinder, cone, sphere];
		

		return obj;
	}

	class WebGlObject {
		constructor(gl,programInfo,vertices,color,position=[0,0,0],orientation=[0,0,0],size=[1,1,1],speed=[0,0,0],orientationChangeRate=[0,0,0],sizeChangeRate=[1,1,1],worldSize=[100,140,80],scaleLimit=[10,10,10]) {
			this.gl = gl;
			this.programInfo = programInfo;
			this.vertices = vertices;
			this.bufferInfo = this.flattenedVertices();
			this.uniforms = {	u_colorMult: color,
							u_matrix: m4.identity(),};
			this.position = position;
			this.rotation = orientation;
			this.scale = size;
			this.speed = speed;
			this.orientationChangeRate = orientationChangeRate;
			this.sizeChangeRate = sizeChangeRate;
			this.time = 0;
			this.worldSize = worldSize;
			this.scaleLimit = scaleLimit;

			this.translation = this.position;
			this.enabled = true;
		}

		flattenedVertices() {
			return webglUtils.createBufferInfoFromArrays(
			    this.gl,
			    primitives.makeRandomVertexColors(
			        primitives.deindexVertices(this.vertices),
			        {
			          vertsPerColor: 6,
			          rand: function(ndx, channel) {
			            return channel < 3 ? ((128 + Math.random() * 128) | 0) : 255;
			          }
			        })
			);
		}

		update(time){
			const delta = (time - this.time)/1000;
			this.time = time;

			this.position = this.simulate(this.position,this.speed,delta);
			this.bounce(this.position,this.speed,this.worldSize,[0,0,-1*this.worldSize[2]]);
			this.translation = [this.position[0]-this.worldSize[0]/2,this.position[1]-this.worldSize[1]/2,this.position[2]-this.worldSize[2]/2];


			this.rotation = this.simulate(this.rotation,this.orientationChangeRate,delta);
			
			this.scale = this.simulateSize(this.scale,this.sizeChangeRate,delta);
			this.bounceScale(this.scaleLimit);
		}

		simulate(vector,changeRate,timeDelta){
			return this.enabled? vecAdd(vector,mult(changeRate,timeDelta)):vector;
		}

		simulateSize(vector,changeRate,timeDelta){
			return this.enabled? vecMult(vector,changeRate):vector;
		}

		bounce(vector,changeRate,limitsHigh,limitsLow){
			for (var i = 0; i < vector.length; i++) {
				if(vector[i]>limitsHigh[i]){
					changeRate[i] = -1* changeRate[i];
					vector[i] = limitsHigh[i];

				}
				if(vector[i]<limitsLow[i]){
					changeRate[i] = -1* changeRate[i];
					vector[i] = limitsLow[i];

				}
			}
		}

		bounceScale(limits){
			var vector = this.scale;

			for (var i = 0; i < vector.length; i++) {
				if(vector[i]>limits[i]){
					this.sizeChangeRate[i] = 1/this.sizeChangeRate[i];
					vector[i] = limits[i];

				} else if(vector[i]<1/limits[i]){
					this.sizeChangeRate[i] = 1/this.sizeChangeRate[i];
					vector[i] = 1/limits[i];				
				}
			}
		}

		limitVector(vector,limits){
			var newVec = [];
			for (var i = 0; i < vector.length; i++) {
				newVec[i] = vector[i] % limits[i];
			}
			return newVec;
		}

		draw(viewProjectionMatrix,time){

			this.gl.useProgram(this.programInfo.program);

			// Setup all the needed attributes.
			webglUtils.setBuffersAndAttributes(this.gl, this.programInfo, this.bufferInfo);

			this.uniforms.u_matrix = this.computeMatrix(
			    viewProjectionMatrix,
			    this.translation,
			    this.rotation,
			    this.scale);

			// Set the uniforms we just computed
			webglUtils.setUniforms(this.programInfo, this.uniforms);

			this.gl.drawArrays(this.gl.TRIANGLES, 0, this.bufferInfo.numElements);
		}

		computeMatrix(viewProjectionMatrix, translation, rotation, scale){
			var matrix = viewProjectionMatrix;

			matrix = m4.translate(matrix,
			    translation[0],
			    translation[1],
			    translation[2]);

			matrix = m4.xRotate(matrix, rotation[0]);

			matrix = m4.yRotate(matrix, rotation[1]);

			matrix = m4.zRotate(matrix, rotation[2]);

			matrix = m4.scale(matrix,
				scale[0],
				scale[1],
				scale[2]);

			return matrix;
		}

		toggle(){
			this.enabled = !this.enabled;
		}
	}

	function main() {
		// Get A WebGL context
		/** @type {HTMLCanvasElement} */
		var canvas = document.getElementById("canvas");
		var gl = canvas.getContext("webgl");
		if (!gl) {
			return;
		}

		// setup GLSL program
		var programInfo = webglUtils.createProgramInfo(gl, ["3d-vertex-shader", "3d-fragment-shader"]);

		objects = createObjects(gl,programInfo);

		requestAnimationFrame(render);

		// Draw the scene.
		function render(time) {
			var t = time /1000;

			webglUtils.resizeCanvasToDisplaySize(gl.canvas);

			// Tell WebGL how to convert from clip space to pixels
			gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

			gl.enable(gl.CULL_FACE);
			gl.enable(gl.DEPTH_TEST);

			// Clear the canvas AND the depth buffer.
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

			// Compute the projection matrix
			var projectionMatrix = getProjectionMatrix(gl);
			//
			
			// Compute the camera's matrix using look at.
			var cameraMatrix = m4.lookAt(cameraPosition, target, up);

			// Make a view matrix from the camera matrix.
			var viewMatrix = m4.inverse(cameraMatrix);

			var viewProjectionMatrix = m4.multiply(projectionMatrix, viewMatrix);

			// ------ Draw Objects --------
			for(const o of objects){
				o.update(time);
				o.draw(viewProjectionMatrix,t);
			}

			requestAnimationFrame(render);
		}

		//
		document.onkeydown = function(e) {
			console.log(e.which);
			if (e.which >= '1'.charCodeAt(0) && e.which <= '9'.charCodeAt(0)){
				objects[e.which-48].toggle();
			}
			else if (e.which == 37){
				cameraPosition[0] -= 1;
				target[0] -= 1;
			}
			else if (e.which == 38){
				cameraPosition[1] += 1;
				target[1] += 1;
			}
			else if (e.which == 39){
				cameraPosition[0] += 1;
				target[0] += 1;
			}
			else if (e.which == 40){
				cameraPosition[1] -= 1;
				target[1] -= 1;
			}
			else if (e.which == 'O'.charCodeAt(0)){
				console.log('ortho');
				view = viewTypes['Orthographic'];
			}
			else if (e.which == 'P'.charCodeAt(0)){
				console.log('Perspective');
				view = viewTypes['Perspective'];
			}
		};

		var viewTypes = {'Orthographic':0,'Perspective':1};

		var view = viewTypes['Perspective'];

		var getProjectionMatrix = function(gl){
			return view == viewTypes['Orthographic']? setViewOrtho(gl):setViewPerspective(gl);
		}

		var setViewOrtho = function (gl) {
			var near = -1;
			var far = 10000;
			var radius = 1.0;
			var theta  = 0.0;
			var phi    = 0.0;
			var dr = 5.0 * Math.PI/180.0;

			var left = -100;
			var right = 100;
			var ytop = 100;
			var bottom = -100;

			var target_width = 120.0;
			var target_height = 200.0;

			var A = target_width / target_height; // target aspect ratio 
			var V = gl.canvas.clientWidth / gl.canvas.clientHeight;
			var mat = [];

			// calculate V as above
			if (V >= A) {
			    // wide viewport, use full height
			    mat = m4.orthographic(-V/A * target_width/2.0, V/A * target_width/2.0, -target_height/2.0, target_height/2.0,  near, far);
			} else {
			    // tall viewport, use full width
			    mat = m4.orthographic(-target_width/2.0, target_width/2.0, -A/V*target_height/2.0, A/V*target_height/2.0,  near, far);
			}

			return mat;
		}



		var setViewPerspective = function (gl) {
			var fieldOfViewRadians = degToRad(60);
			var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
			return m4.perspective(fieldOfViewRadians, aspect, 1, 2000);
		}
	}

	window.onload = main();

</script>
</body>
</html>