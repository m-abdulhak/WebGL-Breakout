<!DOCTYPE html>
<html>
<head>
	<title>Multiple Objects</title>
	<style type="text/css">
		@import url("https://webglfundamentals.org/webgl/resources/webgl-tutorials.css");
		body {
		  margin: 0;
		}
		canvas {
		  width: 100vw;
		  height: 100vh;
		  display: block;
		}
	</style>
</head>
<body>
<canvas id="canvas"></canvas>
<!-- vertex shader -->
<script  id="3d-vertex-shader" type="x-shader/x-vertex">
attribute vec4 a_position;
attribute vec4 a_color;

uniform mat4 u_matrix;

varying vec4 v_color;

void main() {
  // Multiply the position by the matrix.
  gl_Position = u_matrix * a_position;

  // Pass the color to the fragment shader.
  v_color = a_color;
}
</script>
<!-- fragment shader -->
<script  id="3d-fragment-shader" type="x-shader/x-fragment">
precision mediump float;

// Passed in from the vertex shader.
varying vec4 v_color;

uniform vec4 u_colorMult;

void main() {
   gl_FragColor = v_color * u_colorMult;
}
</script>
<script src="common/webgl-utils.js"></script>
<script src="common/m4.js"></script>
<script src="common/primitives.js"></script>

<script type="text/javascript">
	"use strict";

	const red = [1, 0, 0, 1];
	const green = [0, 1, 0, 1];
	const blue = [0.3, 0.3, 1, 1];
	const yellow = [1, 1, 0, 1];
	const magneta = [1, 0, 1, 1];
	const black = [0.1, 0.3, 0.2, .3];

	var objects = [];

	var cameraPosition = [0, 0, 70];
	var target = [cameraPosition[0], cameraPosition[1], cameraPosition[2]-1];
	var up = [0, 100, 0];
	var cameraMatrix = [];
	var orthoscale = 1;
	
	var viewTypes = {'Orthographic':0,'Perspective':1};
	var view = viewTypes['Perspective'];
		
	function degToRad(d){

	    return d * Math.PI / 180;
	}

	function vecAdd(v1,v2){
		var resV = [];
		for (var i = 0; i < v1.length; i++) {
			resV[i] = v1[i]+v2[i];
		}
		return resV;
	}

	function vecMult(v1,v2){
		var resV = [];
		for (var i = 0; i < v1.length; i++) {
			resV[i] = v1[i]*v2[i];
		}
		return resV;
	}

	function mult(v1,scalar) {
		var resV = [];
		for (var i = 0; i < v1.length; i++) {
			resV[i] = v1[i]*scalar;
		}
		return resV;
	}

	function vecMatProduct(vec,mat){
		if(vec.length<4)
			vec.push(0);

		var result = [ 
		vec[0]*mat[0]+vec[1]*mat[1]+vec[2]*mat[2]+vec[3]*mat[3],
		vec[0]*mat[4+0]+vec[1]*mat[4+1]+vec[2]*mat[4+2]+vec[3]*mat[4+3],
		vec[0]*mat[8+0]+vec[1]*mat[8+1]+vec[2]*mat[8+2]+vec[3]*mat[8+3],
		vec[0]*mat[12+0]+vec[1]*mat[12+1]+vec[2]*mat[12+2]+vec[3]*mat[12+3]
		];


		return result;
	}

	function normalize(dir){
		var length = Math.sqrt(dir[0]*dir[0]+dir[1]*dir[1]+dir[2]*dir[2]);

		return length != 0 ? [dir[0]/length,dir[1]/length,dir[2]/length] : dir;
	}

	function rotateZ(vec, theta){
		var cos = Math.cos(theta);
		var sin = Math.sin(theta);

		return [	vec[0]*cos+vec[1]*sin,
					-vec[0]*sin+vec[1]*cos,
					vec[2]
					];
	}

	function rotateY(vec, theta){
		var cos = Math.cos(theta);
		var sin = Math.sin(theta);

		return [	vec[0]*cos-vec[2]*sin,
					vec[1],
					vec[0]*sin+vec[2]*cos
					];
	}

	function rotateX(vec, theta){
		var cos = Math.cos(theta);
		var sin = Math.sin(theta);

		return [	vec[0],
					vec[1]*cos+vec[2]*sin,
					-vec[1]*sin+vec[2]*cos
					];
	}

	var createPlane = function(gl,programInfo,location) {
		var position = location;
		position[0] = 50;
		position[2] = 20;
		var orientation=[0,0,0];
		var size=[8.5,8.5,.1];
		var speed=[0,0,0];
		var orientationChangeRate=[0,0,0];
		var sizeChangeRate=[1,1,1];
		var worldSize=[100,140,180];
		var scaleLimit=[10,10,10];

		return new WebGlObject(gl,
			programInfo,
			primitives.createCubeVertices(20),
			black,
			position,
			orientation,
			size,
			speed,
			orientationChangeRate,
			sizeChangeRate,
			worldSize,
			scaleLimit);
	}

	var createCube = function(gl,programInfo,location) {
		var position = location;
		var orientation=[0,0,0];
		var size=[1,1,1];
		var speed=[0,0,0];
		var orientationChangeRate=[1,1,0];
		var sizeChangeRate=[1,1,1];
		var worldSize=[100,140,80];
		var scaleLimit=[10,10,10];

		return new WebGlObject(gl,
			programInfo,
			primitives.createCubeVertices(20),
			red,
			position,
			orientation,
			size,
			speed,
			orientationChangeRate,
			sizeChangeRate,
			worldSize,
			scaleLimit);
	}

	var createPyramid = function(gl,programInfo,location) {
		// TODO: Translation?
		var position = location;
		var orientation=[0,0,0];
		var size=[1,1,1];
		var speed=[0,0,0];
		var orientationChangeRate=[0,0,0];
		var sizeChangeRate=[1,1,1];
		var worldSize=[100,140,80];
		var scaleLimit=[2,2,2];

		return new WebGlObject(gl, 
			programInfo,
			primitives.createTruncatedConeVertices(10, 0, 20, 3, 1, true, true),
			yellow,
			position,
			orientation,
			size,
			speed,
			orientationChangeRate,
			sizeChangeRate,
			worldSize,
			scaleLimit);
	}

	var createCylinder = function(gl,programInfo,location) {
		var position = location;
		var orientation=[0,0,0];
		var size=[1,1,1];
		var speed=[0,0,0];
		var orientationChangeRate=[0,0,0];
		var sizeChangeRate=[1.001,1.001,1.001];
		var worldSize=[100,140,80];
		var scaleLimit=[2,2,2];

		return new WebGlObject(gl, 
			programInfo,
			primitives.createTruncatedConeVertices(10, 10, 20, 20, 1, true, true),
			blue,
			position,
			orientation,
			size,
			speed,
			orientationChangeRate,
			sizeChangeRate,
			worldSize,
			scaleLimit);
	}

	var createCone = function(gl,programInfo,location) {
		var position = location;
		var orientation=[0,0,0];
		var size=[1,1,1];
		var speed=[0,0,0];
		var orientationChangeRate=[0,0,0];
		var sizeChangeRate=[1.001,1.002,1.003];
		var worldSize=[100,140,80];
		var scaleLimit=[2,2,2];

		return new WebGlObject(gl, 
			programInfo,
			primitives.createTruncatedConeVertices(10, 0, 20, 20, 1, true, true),
			magneta,
			position,
			orientation,
			size,
			speed,
			orientationChangeRate,
			sizeChangeRate,
			worldSize,
			scaleLimit);
	}

	var createSphere = function(gl,programInfo,location) {
		var position = location;
		var orientation=[0,0,0];
		var size=[1,1,1];
		var speed=[10,0,0];
		var orientationChangeRate=[0,0,0];
		var sizeChangeRate=[1,1,1];
		var worldSize=[100,140,80];
		var scaleLimit=[10,10,10];

		return new WebGlObject(gl,
			programInfo,
			primitives.createSphereVertices(10, 10, 10),
			green,
			position,
			orientation,
			size,
			speed,
			orientationChangeRate,
			sizeChangeRate,
			worldSize,
			scaleLimit);
	}

	var createObjects = function(gl,programInfo){
		const locCenter = [0,70,0];
		const locTopRight = [80,110,0];
		const locTopLeft = [20,110,0];
		const locBotRight = [80,30,0];
		const locBotLeft = [20,30,0];

		var plane = createPlane(gl,programInfo,locCenter);

		var cube = createCube(gl,programInfo,locTopLeft);

		var pyramid = createPyramid(gl,programInfo,locTopRight);

		var cylinder = createCylinder(gl,programInfo,locBotLeft);

		var cone = createCone(gl,programInfo,locBotRight);

		var sphere = createSphere(gl,programInfo,locCenter);

		var obj  = [plane, cube, pyramid, cylinder, cone, sphere];
		
		return obj;
	}

	class WebGlObject {
		constructor(gl,programInfo,vertices,color,position=[0,0,0],orientation=[0,0,0],size=[1,1,1],speed=[0,0,0],orientationChangeRate=[0,0,0],sizeChangeRate=[1,1,1],worldSize=[100,140,80],scaleLimit=[10,10,10]) {
			this.gl = gl;
			this.programInfo = programInfo;
			this.vertices = vertices;
			this.bufferInfo = this.flattenedVertices();
			this.uniforms = {	u_colorMult: color,
							u_matrix: m4.identity(),};
			this.position = position;
			this.rotation = orientation;
			this.scale = size;
			this.speed = speed;
			this.orientationChangeRate = orientationChangeRate;
			this.sizeChangeRate = sizeChangeRate;
			this.time = 0;
			this.worldSize = worldSize;
			this.scaleLimit = scaleLimit;

			this.translation = this.position;
			this.enabled = true;
		}

		flattenedVertices() {
			return webglUtils.createBufferInfoFromArrays(
			    this.gl,
			    primitives.makeRandomVertexColors(
			        primitives.deindexVertices(this.vertices),
			        {
			          vertsPerColor: 6,
			          rand: function(ndx, channel) {
			            return channel < 3 ? ((128 + Math.random() * 128) | 0) : 255;
			          }
			        })
			);
		}

		update(time){
			const delta = (time - this.time)/1000;
			this.time = time;

			this.position = this.simulate(this.position,this.speed,delta);
			this.bounce(this.position,this.speed,this.worldSize,[0,0,-1*this.worldSize[2]]);
			this.translation = [this.position[0]-this.worldSize[0]/2,this.position[1]-this.worldSize[1]/2,this.position[2]-this.worldSize[2]/2];


			this.rotation = this.simulate(this.rotation,this.orientationChangeRate,delta);
			
			this.scale = this.simulateSize(this.scale,this.sizeChangeRate,delta);
			this.bounceScale(this.scaleLimit);
		}

		simulate(vector,changeRate,timeDelta){
			return this.enabled? vecAdd(vector,mult(changeRate,timeDelta)):vector;
		}

		simulateSize(vector,changeRate,timeDelta){
			return this.enabled? vecMult(vector,changeRate):vector;
		}

		bounce(vector,changeRate,limitsHigh,limitsLow){
			for (var i = 0; i < vector.length; i++) {
				if(vector[i]>limitsHigh[i]){
					changeRate[i] = -1* changeRate[i];
					vector[i] = limitsHigh[i];

				}
				if(vector[i]<limitsLow[i]){
					changeRate[i] = -1* changeRate[i];
					vector[i] = limitsLow[i];

				}
			}
		}

		bounceScale(limits){
			var vector = this.scale;

			for (var i = 0; i < vector.length; i++) {
				if(vector[i]>limits[i]){
					this.sizeChangeRate[i] = 1/this.sizeChangeRate[i];
					vector[i] = limits[i];

				} else if(vector[i]<1/limits[i]){
					this.sizeChangeRate[i] = 1/this.sizeChangeRate[i];
					vector[i] = 1/limits[i];				
				}
			}
		}

		limitVector(vector,limits){
			var newVec = [];
			for (var i = 0; i < vector.length; i++) {
				newVec[i] = vector[i] % limits[i];
			}
			return newVec;
		}

		draw(viewProjectionMatrix,time){

			this.gl.useProgram(this.programInfo.program);

			// Setup all the needed attributes.
			webglUtils.setBuffersAndAttributes(this.gl, this.programInfo, this.bufferInfo);

			this.uniforms.u_matrix = this.computeMatrix(
			    viewProjectionMatrix,
			    this.translation,
			    this.rotation,
			    this.scale);

			// Set the uniforms we just computed
			webglUtils.setUniforms(this.programInfo, this.uniforms);

			this.gl.drawArrays(this.gl.TRIANGLES, 0, this.bufferInfo.numElements);
		}

		computeMatrix(viewProjectionMatrix, translation, rotation, scale){
			var matrix = viewProjectionMatrix;

			matrix = m4.translate(matrix,
			    translation[0],
			    translation[1],
			    translation[2]);

			matrix = m4.xRotate(matrix, rotation[0]);

			matrix = m4.yRotate(matrix, rotation[1]);

			matrix = m4.zRotate(matrix, rotation[2]);

			matrix = m4.scale(matrix,
				scale[0],
				scale[1],
				scale[2]);

			return matrix;
		}

		toggle(){
			this.enabled = !this.enabled;
		}
	}

	function main() {
		// Get A WebGL context
		/** @type {HTMLCanvasElement} */
		var canvas = document.getElementById("canvas");
		var gl = canvas.getContext("webgl");
		if (!gl) {
			return;
		}

		// setup GLSL program
		var programInfo = webglUtils.createProgramInfo(gl, ["3d-vertex-shader", "3d-fragment-shader"]);

		objects = createObjects(gl,programInfo);

		requestAnimationFrame(render);

		// Draw the scene.
		function render(time) {
			var t = time /1000;

			webglUtils.resizeCanvasToDisplaySize(gl.canvas);

			// Tell WebGL how to convert from clip space to pixels
			gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

			gl.enable(gl.CULL_FACE);
			gl.enable(gl.DEPTH_TEST);

			// Clear the canvas AND the depth buffer.
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

			// Compute the projection matrix
			var projectionMatrix = getProjectionMatrix(gl);
			
			// Compute the camera's matrix using look at.
			cameraMatrix = m4.lookAt(cameraPosition, target, up);

			// Make a view matrix from the camera matrix.
			var viewMatrix = m4.inverse(cameraMatrix);

			var viewProjectionMatrix = m4.multiply(projectionMatrix, viewMatrix);

			// ------ Draw Objects --------
			for(const o of objects){
				o.update(time);
				o.draw(viewProjectionMatrix,t);
			}

			requestAnimationFrame(render);
		}

		document.onkeydown = function(e) {
			var dir = [-cameraPosition[0]+target[0],
							-cameraPosition[1]+target[1],
							-cameraPosition[2]+target[2],
							0];

			var normDir = normalize(dir);

			if (e.which >= '1'.charCodeAt(0) && e.which <= '9'.charCodeAt(0)){
				objects[e.which-48].toggle();
			}
			else if (e.which == 'W'.charCodeAt(0)){ // Forward
				cameraPosition = vecAdd(cameraPosition,normDir);
				target = vecAdd(target,normDir);
				orthoscale *= .99; 
			}
			else if (e.which == 'S'.charCodeAt(0)){ // Back
				cameraPosition = vecAdd(cameraPosition,mult(normDir,-1));
				target = vecAdd(target,mult(normDir,-1));
				orthoscale *= 1.01; 
			}
			else if (e.which == 'A'.charCodeAt(0)){ // left
				var newDir = rotateY(normDir,-0.2);
				target = vecAdd(cameraPosition,newDir);
			}
			else if (e.which == 'D'.charCodeAt(0)){ // right
				var newDir = rotateY(normDir,0.2);
				target = vecAdd(cameraPosition,newDir);
			}
			else if (e.which == 'E'.charCodeAt(0)){ // up
				var dirInCamerCoor = normalize(vecMatProduct(normDir,cameraMatrix));
				var newDirInCamerCoor = normalize(rotateX([dirInCamerCoor[0],dirInCamerCoor[1],dirInCamerCoor[2]],-0.2));
				var newDir = normalize(vecMatProduct(newDirInCamerCoor,m4.inverse(cameraMatrix)));
				if(newDir[1]<0.8){
					target = vecAdd(cameraPosition,newDir);
				}
			}
			else if (e.which == 'Q'.charCodeAt(0)){ // down
				var dirInCamerCoor = normalize(vecMatProduct(normDir,cameraMatrix));
				var newDirInCamerCoor = normalize(rotateX([dirInCamerCoor[0],dirInCamerCoor[1],dirInCamerCoor[2]],0.2));
				var newDir = normalize(vecMatProduct(newDirInCamerCoor,m4.inverse(cameraMatrix)));
				if(newDir[1]>-0.8){
					target = vecAdd(cameraPosition,newDir);
				}
			}

			else if (e.which == 'T'.charCodeAt(0)){
			}
			else if (e.which == 'G'.charCodeAt(0)){
			}
			else if (e.which == 'O'.charCodeAt(0)){
				console.log('Orthographic');
				view = viewTypes['Orthographic'];
			}
			else if (e.which == 'P'.charCodeAt(0)){
				console.log('Perspective');
				view = viewTypes['Perspective'];
			}
		};

		var getProjectionMatrix = function(gl){

			return view == viewTypes['Orthographic']? setViewOrtho(gl):setViewPerspective(gl);
		}

		var setViewOrtho = function (gl) {
			var near = -1;
			var far = 10000;
			var radius = 1.0;

			var target_width = 120.0 * orthoscale;
			var target_height = 200.0 * orthoscale;

			var A = target_width / target_height; // target aspect ratio 
			var V = gl.canvas.clientWidth / gl.canvas.clientHeight;


			var mat = [];

			// calculate V as above
			if (V >= A) {
			    // wide viewport, use full height
			    mat = m4.orthographic(-V/A * target_width/2.0, V/A * target_width/2.0, -target_height/2.0, target_height/2.0,  near, far);
			} else {
			    // tall viewport, use full width
			    mat = m4.orthographic(-target_width/2.0, target_width/2.0, -A/V*target_height/2.0, A/V*target_height/2.0,  near, far);
			}

			return mat;
		}

		var setViewPerspective = function (gl) {
			var fieldOfViewRadians = degToRad(60);
			var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
			return m4.perspective(fieldOfViewRadians, aspect, 1, 2000);
		}
	}

	window.onload = main();

</script>
</body>
</html>