<!DOCTYPE html>
<html>
<head>
	<title>WebGL Transformations, Navigation and Projections</title>
	<style type="text/css">
		@import url("https://webglfundamentals.org/webgl/resources/webgl-tutorials.css");
		body {
		  margin: 0;
		}
		canvas {
		  width: 100vw;
		  height: 100vh;
		  display: block;
		  cursor: none; 
		}
		#sidebar{
			height: 100%;
			width: 400px;
			position:fixed;
			top:0px;
			right: 0px;
			background-color: #d3d3d37d;
			border: 1px #989898 solid;
			font-size:1.5em;
			text-align: center;
			overflow: scroll;
			line-height: 1.4em;
		}
		.key{
			color: #34a21a;
			font-weight: 700;
		}
		.active{
			font-weight: 900;
		}
		.hidden{
			display: none;
		}
		#pause_screen{
			width: 100%;
			height: 100%;
			position: fixed;
			left: 0;
			top: 0;
			text-align: center;
			color: #FFFFFA;
			background: #6b6971;
			font-size: 3em;
			font-family: sans-serif;
		}
		.pause_title{ 
			position: absolute;
			left: 0;
			right: 0;
			top: 40%;
		}
	</style>
</head>
<body>
<div id="pause_screen" class="hidden"><h1 class="pause_title">Press Space To Continue!</h1></div>
<canvas id="canvas"></canvas>
<div id="sidebar" style="display: none;">
	<h4>WebGL Transformations, Navigation and Projections</h4>
	<span class="key">W - S</span> 
	<br>
	<span class="action">Move Forwards / Backwards</span>
	<br>
	<br>
	<span class="key">A - D</span> 
	<br>
	<span class="action">Turn Left / Right</span>
	<br>
	<br>
	<span class="key">E - Q</span> 
	<br>
	<span class="action">Look Up / Down</span>
	<br>
	<br>
	<span class="key">1 - 2 - 3 - 4 - 5</span> 
	<br>
	<span class="action">Toggle Animation For <br>Shapes (1-5)</span>
	<br>
	<br>
	<span class="key">O - P</span> 
	<br>
	<span class="action"><span id="ortho">Orthographic</span> / <span id="perspective" class="active">Perspective</span> </span>
	<br>
	<br>
	<span class="key">X</span> 
	<br>
	<span class="action">Show / Hide Sidebar</span>
	<br>
	<br>
	<span style="font-size: 0.6em;">Made By <a href="mailto:m_abdulhak@outlook.com">Mohammed Abdullhak</a></span>
	<br>
	<span style="font-size: 0.6em;"><a href="https://github.com/m-abdulhak/WebGLTransformations">Source Code</a></span>
</div>

<!-- vertex shader -->
<script  id="3d-vertex-shader" type="x-shader/x-vertex">
attribute vec4 a_position;
attribute vec4 a_normal;
attribute vec4 a_color;

uniform mat4 u_matrix;
uniform mat4 u_modelViewMatrix;
uniform mat4 u_projectionMatrix;

uniform vec3 u_viewWorldPosition;

// TODO: change to array
uniform vec4 u_lightPosition0;
uniform vec4 u_lightPosition1;
uniform vec4 u_lightPosition2;
uniform vec4 u_lightPosition3;

// TODO: change to array
uniform vec3 u_lightDirection0;
uniform vec3 u_lightDirection1;
uniform vec3 u_lightDirection2;
uniform vec3 u_lightDirection3;

// TODO: change to arrays
uniform vec3 u_ambientColor0;
uniform vec3 u_diffuseColor0;
uniform vec3 u_specularColor0;

uniform vec3 u_ambientColor1;
uniform vec3 u_diffuseColor1;
uniform vec3 u_specularColor1;

uniform vec3 u_ambientColor2;
uniform vec3 u_diffuseColor2;
uniform vec3 u_specularColor2;

uniform vec3 u_ambientColor3;
uniform vec3 u_diffuseColor3;
uniform vec3 u_specularColor3;

// Pass to fragment shader
varying vec4 lightPositions[4];
varying vec3 lightDirections[4];
varying vec3 diffuseColors[4];
varying vec3 specularColors[4];
varying vec3 ambientColors[4];

varying vec3 v_normal;
varying vec3 v_surfaceToLight[4];
varying vec3 v_surfaceToView;


void main() {
	
	// TODO: remove after changing uniforms into arrays
	diffuseColors[0] = u_diffuseColor0;
	diffuseColors[1] = u_diffuseColor1;
	diffuseColors[2] = u_diffuseColor2;
	diffuseColors[3] = u_diffuseColor3;
	specularColors[0] = u_specularColor0;
	specularColors[1] = u_specularColor1;
	specularColors[2] = u_specularColor2;
	specularColors[3] = u_specularColor3;
	ambientColors[0] = u_ambientColor0;
	ambientColors[1] = u_ambientColor1;
	ambientColors[2] = u_ambientColor2;
	ambientColors[3] = u_ambientColor3;
	lightPositions[0] = u_lightPosition0;
	lightPositions[1] = u_lightPosition1;
	lightPositions[2] = u_lightPosition2;
	lightPositions[3] = u_lightPosition3;
	lightDirections[0] = u_lightDirection0;
	lightDirections[1] = u_lightDirection1;
	lightDirections[2] = u_lightDirection2;
	lightDirections[3] = u_lightDirection3;

	// Multiply the position by the matrix.
	gl_Position = u_projectionMatrix * u_modelViewMatrix * u_matrix * a_position;

	// orient the normals and pass to the fragment shader
	v_normal = mat3(u_matrix) * a_normal.xyz;

	// compute the world position of the surfoace
	vec3 surfaceWorldPosition = (u_matrix * a_position).xyz;

	// compute the vector of the surface to the light
	// and pass it to the fragment shader	
	for(int i = 0; i < 4; i++) {
		v_surfaceToLight[i] = lightPositions[i].xyz - surfaceWorldPosition;
	}

	// compute the vector of the surface to the view/camera
	// and pass it to the fragment shader
	v_surfaceToView = u_viewWorldPosition - surfaceWorldPosition;
	
}
</script>

<!-- fragment shader -->
<script  id="3d-fragment-shader" type="x-shader/x-fragment">
precision mediump float;

uniform vec4 u_surfaceColor;
uniform float u_shininess;
uniform float u_shadow;
uniform int u_shadow_light_index;
uniform float u_spotlightInnerLimit;
uniform float u_spotlightOuterLimit;

// Passed in from the vertex shader.
varying vec3 v_normal;
varying vec3 v_surfaceToLight[4];
varying vec3 v_surfaceToView;

varying vec4 lightPositions[4];
varying vec3 lightDirections[4];
varying vec3 diffuseColors[4];
varying vec3 specularColors[4];
varying vec3 ambientColors[4];

void main() {

	// because v_normal is a varying it's interpolated
	// so it will not be a unit vector. Normalizing it
	// will make it a unit vector again
	vec3 surfaceNormal = normalize(v_normal);

	gl_FragColor = u_surfaceColor;
	vec3 diffusedLights = vec3(0.0, 0.0, 0.0);
	vec3 specularLights = vec3(0.0, 0.0, 0.0);
	vec3 ambientLights = vec3(0.0, 0.0, 0.0);

	for(int i = 0; i < 4; i++) {
		vec3 surfaceToLightDirection = normalize(v_surfaceToLight[i]);
		vec3 surfaceToViewDirection = normalize(v_surfaceToView);
		vec3 halfVector = normalize(surfaceToLightDirection + surfaceToViewDirection);

		float light = dot(surfaceNormal, surfaceToLightDirection);

		float coef = 1.0;

		if(lightPositions[i].a == 0.0){
			// check if current position is within spotlight limit 
			vec3 lightDirectionsNorm = normalize(lightDirections[i]);
			float dotFromDirection = dot(surfaceToLightDirection,-lightDirections[i]);

			coef = smoothstep(u_spotlightOuterLimit, u_spotlightInnerLimit, dotFromDirection);;
		}

		float specular = 0.0;
		if (light > 0.0) {
			specular = pow(dot(surfaceNormal, halfVector), u_shininess);
		}

		// Lets multiply just the color portion (not the alpha)
		// by the light
		diffusedLights.rgb += light * diffuseColors[i] * coef;

		// Just add in the specular
		specularLights.rgb += specular * specularColors[i] * coef;

		// Add ambientColor
		ambientLights.rgb += ambientColors[i] * coef;
		
		// TODO: remove ambient light of current light under its shadow
		// this does not work, causes flickering if overlaping with other shadows
		if(u_shadow==1.0  && u_shadow_light_index == i){
			//ambientLights.rgb -= ambientColors[i];
		}
	}
	
	gl_FragColor.rgb *= diffusedLights ;

	// Just add in the specular
	gl_FragColor.rgb += specularLights;

	// Add ambientColor
	gl_FragColor.rgb += ambientLights;
	
	// if redndering a shoadow only keep ambientLights
	if(u_shadow==1.0){
		gl_FragColor = vec4(.0, .0, .0, 1.0);
		gl_FragColor.rgb += ambientLights;
	}
}
</script>
<script src="common/webgl-utils.js"></script>
<script src="common/m4.js"></script>
<script src="common/primitives.js"></script>
<script type="text/javascript" src="common/MV.js"></script>

<script type="text/javascript">
	"use strict";

	var scene;
	var paused = false;

	var cameraPosition = [70, 70, 220];
	var target = [cameraPosition[0], cameraPosition[1], cameraPosition[2]-1];
	var up = [0, 100, 0];
	var cameraMatrix = [];
	var viewMatrix = [];
	var projectionMatrix = [];
	var orthoscale = 1;
	
	var viewTypes = {'Orthographic':0,'Perspective':1};
	var view = viewTypes['Perspective'];
		
	// My Lighting 
	// Lighting
	// vec4
	var lightPosition = [[70, 70, 40, 1.0 ], [140, 140, 80, 1.0 ], [0, 140, 80, 1.0 ], [70, 70, 220, 0.0 ]];
	var lightDirection = [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0., 0., -1.0]];
	var lightColor = [[1.0, 1.0, 1.0],[.5, .0, .0],[.0, .5, .0],[1.0, 1.0, 1.0]];
	var lightAmbient = [multByScalar(lightColor[0], 0.1), multByScalar(lightColor[1], 0.05), multByScalar(lightColor[2], 0.05), multByScalar(lightColor[3], 0.05)];
	var lightDiffuse = [multByScalar(lightColor[0], 0.3), multByScalar(lightColor[1], 0.3), multByScalar(lightColor[2], 0.3), multByScalar(lightColor[3], .5)];
	var lightSpecular = [multByScalar(lightColor[0], .9), multByScalar(lightColor[1], .7), multByScalar(lightColor[2], .7), multByScalar(lightColor[3], 1.0)];
	var spotlightOuterLimit = 0.8;
	var spotlightInnerLimit = 0.9;

	// Shadows
	var xyPlaneShadowsTransformationMatrix = [];

	function degToRad(d){

	    return d * Math.PI / 180;
	}

	function vecAdd(v1,v2){
		var resV = [];
		for (var i = 0; i < v1.length; i++) {
			resV[i] = v1[i]+v2[i];
		}
		return resV;
	}

	function multByScalar(v1,scalar) {
		var resV = [];
		for (var i = 0; i < v1.length; i++) {
			resV[i] = v1[i]*scalar;
		}
		return resV;
	}

	function vecMatProduct(vec,mat){
		if(vec.length<4)
			vec.push(0);

		var result = [ 
		vec[0]*mat[0]+vec[1]*mat[1]+vec[2]*mat[2]+vec[3]*mat[3],
		vec[0]*mat[4+0]+vec[1]*mat[4+1]+vec[2]*mat[4+2]+vec[3]*mat[4+3],
		vec[0]*mat[8+0]+vec[1]*mat[8+1]+vec[2]*mat[8+2]+vec[3]*mat[8+3],
		vec[0]*mat[12+0]+vec[1]*mat[12+1]+vec[2]*mat[12+2]+vec[3]*mat[12+3]
		];


		return result;
	}

	function normalize(dir){
		var length = Math.sqrt(dir[0]*dir[0]+dir[1]*dir[1]+dir[2]*dir[2]);
		var normalized = [dir[0]/length,dir[1]/length,dir[2]/length];
		normalized = dir.length == 4 ? normalized.concat(dir[3]) : normalized;

		return length != 0 ? normalized : dir;
	}

	function rotateZ(vec, theta){
		var cos = Math.cos(theta);
		var sin = Math.sin(theta);

		return [	vec[0]*cos+vec[1]*sin,
					-vec[0]*sin+vec[1]*cos,
					vec[2]
					];
	}

	function rotateY(vec, theta){
		var cos = Math.cos(theta);
		var sin = Math.sin(theta);

		return [	vec[0]*cos-vec[2]*sin,
					vec[1],
					vec[0]*sin+vec[2]*cos
					];
	}

	function rotateX(vec, theta){
		var cos = Math.cos(theta);
		var sin = Math.sin(theta);

		return [	vec[0],
					vec[1]*cos+vec[2]*sin,
					-vec[1]*sin+vec[2]*cos
					];
	}

	class ShapeFactory {
		constructor (gl,programInfo){
		this.gl = gl;
		this.programInfo = programInfo;

		// Consts
		this.DefShapeSettings = {
			position : [0,0,0],
			speed : [0,0,0],
			positionLimits : {
						"Max" : [1000, 1000, 1000],
						"Min" : [-1000, -1000,-1000]
			},
			orientation : [0,0,0],
			angularSpeed : [0,0,0],
			size : [1,1,1],
			sizeChangeRate : [1,1,1],	
			scaleLimit: [2,2,2],			
			material: {	"materialAmbient" : [ 1.0, 1.0, 1.0 ],
				"materialDiffuse" : [ 1.0, 1.0, 1.0 ],
				"materialSpecular" : [ .3, .3, .3 ],
				"materialShininess" : 5.0},
			hasShadow:true,
			isLight: false};

		this.Shapes = {
			"Plane" : primitives.createCubeVertices(20),
			"Sphere" : primitives.createSphereVertices(10, 60, 60),
			"Cube" : primitives.createCubeVertices(20),
			"Pyramid" : primitives.createTruncatedConeVertices(10, 0, 20, 30, 10, true, true),
			"Cylinder" : primitives.createTruncatedConeVertices(10, 10, 20, 60, 1, true, true),
			"Cone" : primitives.createTruncatedConeVertices(10, 0, 20, 60, 1, true, true)};
		this.Colors = {
			"Red" : [1, 0.1, 0.1, 1],
			"Green" : [0.1, 1, 0.1, 1],
			"Blue" : [0.3, 0.3, 1, 1],
			"Yellow" : [1, 1, 0.1, 1],
			"Magneta" : [1, 0.1, 1, 1],
			"Gray" : [0.3, 0.3, 0.3, 1],
			"Black" : [0.1, 0.1, 0.1, 1],
			"White" : [1.0, 1.0, 1.0, 1.0],
			"Glowing" : [1, 1, 1, 1]};
		this.Materials = {
			"Matt" : {	"materialAmbient" : [ 1.0, 1.0, 1.0 ],
				"materialDiffuse" : [ 1.0, 1.0, 1.0 ],
				"materialSpecular" : [ 0.5, 0.5, 0.5 ],
				"materialShininess" : 5.0},
			"Shiny" : {	"materialAmbient" : [ 1.0, 1.0, 1.0 ],
				"materialDiffuse" : [ 1.0, 1.0, 1.0 ],
				"materialSpecular" : [ 1.0, 1.0, 1.0 ],
				"materialShininess" : 10.0},
			"Mirror" : {	"materialAmbient" : [ 1.0, 1.0, 1.0 ],
				"materialDiffuse" : [ 0.8, 0.8, 0.8 ],
				"materialSpecular" : [ 1.0, 1.0, 1.0 ],
				"materialShininess" : 10000.0},
			"Light" : {	"materialAmbient" : [ 100.0, 100.0, 100.0 ],
				"materialDiffuse" : [ 1.0, 1.0, 1.0 ],
				"materialSpecular" : [ 100.0, 100.0, 100.0 ],
				"materialShininess" : 1.0}						
			};
			this.DefaultColor = this.Colors.Red;
		}

		getDefaultsWith(parObject){
			var settings = {...this.DefShapeSettings};
			
			for (var k in parObject) {
				if (parObject.hasOwnProperty(k)) {
					settings[k] = parObject[k];
				}
			}
			//console.log(parObject,settings)
			return settings;
		}
		
		createShape = function(shape, location, color, parameters) {
			// print shpae info
			//console.log(shape);
			const settings = parameters == null? this.DefShapeSettings : parameters;
			const col = color == null? this.defaultColor : color;
			const loc = location;

			return new WebGlObject(
				this.gl,
				this.programInfo,
				shape,
				col,
				loc,
				settings.speed,
				settings.positionLimits,
				settings.orientation,
				settings.angularSpeed,
				settings.size,
				settings.sizeChangeRate,
				settings.scaleLimit,	
				settings.material.materialAmbient,
				settings.material.materialDiffuse,
				settings.material.materialSpecular,
				settings.material.materialShininess,
				settings.hasShadow,
				settings.isLight,		
				settings.lightIndex);
		}
	}

	class Scene{
		constructor(gl,programInfo){
			this.gl = gl;
			this.programInfo = programInfo;
			this.ShapeFactory = new ShapeFactory(gl,programInfo);
			this.Positions = {
				"Center" : [2.5,2.5,0.8],
				"TopLeft" : [1,4,0.8],
				"TopRight" : [4,4,0.8],
				"BottomLeft" : [1,1,0.8],
				"BottomRight" : [4,1,0.8]};
			this.objects = [];
		}

		getPosition(position){
			const stepSize = [30, 30, 30];
			return [position[0]*stepSize[0],position[1]*stepSize[1],position[2]*stepSize[2]];
		}

		createObjects (){
			var sF = this.ShapeFactory;

			var position = this.getPosition(this.Positions.Center);
			position[2]=-1.1;
			var parameters = sF.getDefaultsWith({"size":[50,50,.1], "scaleLimit": [100,100,100], "material": sF.Materials.Mirror, "hasShadow": false});
			this.objects.push(sF.createShape(sF.Shapes.Plane,position,sF.Colors.Red,parameters));

			position = this.getPosition(this.Positions.TopLeft);
			parameters = sF.getDefaultsWith({"angularSpeed":[.1,.1,0]});
			this.objects.push(sF.createShape(sF.Shapes.Cube,position,sF.Colors.Red,parameters));
			
			position = this.getPosition(this.Positions.TopRight);
			parameters = sF.getDefaultsWith({"speed":[1,1,0], "positionLimits" : {"Max": [140, 140,1000] , "Min": [100, 100,-1000]}, "angularSpeed":[-1,-1,-1],"sizeChangeRate":[1.1,1.005,1.005],"scaleLimit":[2,2,2], "material": sF.Materials.Shiny});
			this.objects.push(sF.createShape(sF.Shapes.Pyramid,position,sF.Colors.Yellow,parameters));

			position = this.getPosition(this.Positions.Center);
			parameters = sF.getDefaultsWith({"speed":[10,0,0], "positionLimits" : {"Max": [120,70,1000] , "Min": [20,40,-1000]}, "material": sF.Materials.Shiny});
			this.objects.push(sF.createShape(sF.Shapes.Sphere,position,sF.Colors.Green,parameters));


			position = this.getPosition(this.Positions.BottomLeft);
			parameters = sF.getDefaultsWith({"sizeChangeRate":[1.001,1.001,1.001], "scaleLimit": [1.2,1.2,1.2], "material": sF.Materials.Shiny});
			this.objects.push(sF.createShape(sF.Shapes.Cylinder,position,sF.Colors.Blue,parameters));

			position = this.getPosition(this.Positions.BottomRight);
			parameters = sF.getDefaultsWith({"sizeChangeRate":[0.999,0.998,0.997], "scaleLimit": [1.2,1.2,1.2]});
			this.objects.push(sF.createShape(sF.Shapes.Cone,position,sF.Colors.Magneta,parameters));

			// Attach lights
			position = [100,100,60];
			parameters = sF.getDefaultsWith({"size":[.1,.1,.1], "scaleLimit": [10000,10000,10000], "speed":[10,20,0], "positionLimits" : {"Max": [140, 140,1000] , "Min": [0, 0,-1000]}, "material": sF.Materials.Light , "isLight": true, "lightIndex": 1, "hasShadow": false});
			this.objects.push(sF.createShape(sF.Shapes.Sphere,position,sF.Colors.Glowing,parameters));
		}

		render(time){
			var t = time /1000;
			for(const o of this.objects){
				o.update(time);
				o.draw(t);
			}
		}

		toggleAnimation(objIndex){
			this.objects[objIndex].toggleAnimation();
		}			
	}

	class WebGlObject {
		constructor(gl, 
					programInfo, 
					vertices, 
					color, 
					position=[0,0,0], 
					speed=[0,0,0], 
					positionLimits = {
						"Max" : [1000, 1000, 1000],
						"Min" : [-1000, -1000,-1000]
					},
					orientation=[0,0,0], 
					orientationChangeRate=[0,0,0],
					size=[1,1,1],  
					sizeChangeRate=[1,1,1], 
					scaleLimit=[10,10,10],			
					materialAmbient = [ 1.0, 1.0, 1.0 ],
					materialDiffuse = [ 1.0, 1.0, 1.0 ],
					materialSpecular = [ 1.0, 1.0, 1.0 ],
					materialShininess = 20.0,
					hasShadow = true,
					isLight = false,
					lightIndex) {

			this.gl = gl;
			this.programInfo = programInfo;
			
			// Contains vertices' positions, normals, texcoords, and indices
			this.vertices = vertices;
			//console.log("vertices:",vertices);

			this.bufferInfo = this.flattenedVertices();
			this.uniforms = {	u_surfaceColor: color,
							};
			this.position = position;
			this.positionLimits = positionLimits;
			this.rotation = orientation;
			this.scale = size;
			this.speed = speed;
			this.orientationChangeRate = orientationChangeRate;
			this.sizeChangeRate = sizeChangeRate;
			this.time = 0;
			this.scaleLimit = scaleLimit;

			this.translation = this.position;
			this.enabled = true;

			// material properties
			this.materialAmbient = materialAmbient;
			this.materialDiffuse = materialDiffuse;
			this.materialSpecular = materialSpecular;
			this.materialShininess = materialShininess;

			// Shadow
			this.hasShadow = hasShadow;
			
			// lighting
			this.isLight = isLight;
			this.lightIndex = lightIndex;

			// print buffer info
			//console.log(this.bufferInfo);
			//console.log(this);
		}

		flattenedVertices() {
			return webglUtils.createBufferInfoFromArrays(
			    this.gl,
			    primitives.makeRandomVertexColors(
			        primitives.deindexVertices(this.vertices),
			        {
			          vertsPerColor: 6,
			          rand: function(ndx, channel) {
			            return channel < 3 ? ((128 + Math.random() * 128) | 0) : 255;
			          }
			        })
			);
		}

		update(time){
			const delta = (time - this.time)/1000;
			this.time = time;

			this.position = this.simulate(this.position,this.speed,delta);
			this.bounce(this.position,this.speed, this.positionLimits.Max,this.positionLimits.Min);
			this.translation = [this.position[0],this.position[1],this.position[2]];

			this.rotation = this.simulate(this.rotation,this.orientationChangeRate,delta);
			
			this.scale = this.simulateSize(this.scale,this.sizeChangeRate,delta);
			this.bounceScale(this.scaleLimit);
		}

		simulate(vector,changeRate,timeDelta){
			if(this.enabled){
				if(this.isLight) {
					lightPosition[0] = this.position;
					lightPosition[0][3] = 1;
					//console.log('islight:',this.isLight,this.position,lightPosition)
				}
				return vecAdd(vector,multByScalar(changeRate,timeDelta));
			}
			else{
				return vector;
			}
		}

		simulateSize(vector,changeRate,timeDelta){
			return this.enabled? mult(vector,changeRate):vector;
		}

		bounce(vector,changeRate,limitsHigh,limitsLow){
			for (var i = 0; i < vector.length; i++) {
				if(vector[i]>limitsHigh[i]){
					changeRate[i] = -1* changeRate[i];
					vector[i] = limitsHigh[i];
				}
				if(vector[i]<limitsLow[i]){
					changeRate[i] = -1* changeRate[i];
					vector[i] = limitsLow[i];
				}
			}
		}

		bounceScale(limits){
			var vector = this.scale;

			for (var i = 0; i < vector.length; i++) {
				if(vector[i]>limits[i]){
					this.sizeChangeRate[i] = 1/this.sizeChangeRate[i];
					vector[i] = limits[i];
				} else if(vector[i]<1/limits[i]){
					this.sizeChangeRate[i] = 1/this.sizeChangeRate[i];
					vector[i] = 1/limits[i];				
				}
			}
		}

		limitVector(vector,limits){
			var newVec = [];
			for (var i = 0; i < vector.length; i++) {
				newVec[i] = vector[i] % limits[i];
			}
			return newVec;
		}

		draw(time){

			this.gl.useProgram(this.programInfo.program);

			// Setup all the needed attributes.
			webglUtils.setBuffersAndAttributes(this.gl, this.programInfo, this.bufferInfo);

			this.uniforms.u_matrix = this.computeMatrix(
			    this.translation,
			    this.rotation,
				this.scale);

			var transfMatrix = this.computeMatrix(
				m4.identity(),
			    [0,0,0],
			    this.rotation,
				this.scale);
				
			this.uniforms.u_transformation_matrix = transfMatrix;
			this.uniforms.u_modelViewMatrix = viewMatrix;
			this.uniforms.u_projectionMatrix = projectionMatrix;
			this.uniforms.u_viewWorldPosition = cameraPosition;

			var ambientProduct = [];
			var diffuseProduct = [];
			var specularProduct = [];

			// Update my lighting parameters
			for (let index = 0; index < lightAmbient.length; index++) {
				ambientProduct[index] = mult(lightAmbient[index], this.materialAmbient);
				diffuseProduct[index] = mult(lightDiffuse[index], this.materialDiffuse);
				specularProduct[index] = mult(lightSpecular[index], this.materialSpecular);
			}

			this.uniforms.u_lightPosition0 = lightPosition[0];			
			this.uniforms.u_lightDirection0 = lightDirection[0];			
			this.uniforms.u_ambientColor0 = ambientProduct[0];
			this.uniforms.u_diffuseColor0 = diffuseProduct[0];
			this.uniforms.u_specularColor0 = specularProduct[0];
			this.uniforms.u_lightPosition1 = lightPosition[1];		
			this.uniforms.u_lightDirection1 = lightDirection[1];			
			this.uniforms.u_ambientColor1 = ambientProduct[1];
			this.uniforms.u_diffuseColor1 = diffuseProduct[1];
			this.uniforms.u_specularColor1 = specularProduct[1];
			this.uniforms.u_lightPosition2 = lightPosition[2];		
			this.uniforms.u_lightDirection2 = lightDirection[2];			
			this.uniforms.u_ambientColor2 = ambientProduct[2];
			this.uniforms.u_diffuseColor2 = diffuseProduct[2];
			this.uniforms.u_specularColor2 = specularProduct[2];
			this.uniforms.u_lightPosition3 = lightPosition[3];		
			this.uniforms.u_lightDirection3 = lightDirection[3];			
			this.uniforms.u_ambientColor3 = ambientProduct[3];
			this.uniforms.u_diffuseColor3 = diffuseProduct[3];
			this.uniforms.u_specularColor3 = specularProduct[3];
			this.uniforms.u_shininess = this.materialShininess;

			this.uniforms.u_shadow = 0.0;
			this.uniforms.u_spotlightInnerLimit = spotlightInnerLimit;
			this.uniforms.u_spotlightOuterLimit = spotlightOuterLimit;

			// Set the uniforms we just computed
			webglUtils.setUniforms(this.programInfo, this.uniforms);

			this.gl.drawArrays(this.gl.TRIANGLES, 0, this.bufferInfo.numElements);

			if(this.hasShadow){
				for (let index = 0; index < lightPosition.length; index++) {
					// if light is very dim do not render its shadow
					// reduce function returns the summ of RGB intensities
					if(lightColor[index].reduce((a,b) => a + b, 0) < 0.1)
						continue;

					// model-view matrix for shadow then render
					var black = vec4(0.0, 0.0, 0.0, 1.0);
					var lightSource = lightPosition[index];
					var para1 = translate(lightSource[0], lightSource[1], lightSource[2]);
					var src = viewMatrix;
					para1[0] = [src[0],src[4],src[8],src[12]];
					para1[1] = [src[1],src[5],src[9],src[13]];
					para1[2] = [src[2],src[6],src[10],src[14]];
					para1[3] = [src[3],src[7],src[11],src[15]];
					var para2 = translate(lightSource[0], lightSource[1], lightSource[2]);
					var shadow_modelViewMatrix = mult(para1, para2);

					xyPlaneShadowsTransformationMatrix[index] = mat4();
					xyPlaneShadowsTransformationMatrix[index][3][3] = 0;
					xyPlaneShadowsTransformationMatrix[index][3][2] = -1/lightPosition[index][2];
	
					//console.log("modelViewMatrix:",para1,"translate:",para2,"modelViewMatrix",shadow_modelViewMatrix)
					shadow_modelViewMatrix = mult(shadow_modelViewMatrix, xyPlaneShadowsTransformationMatrix[index]);
					shadow_modelViewMatrix = mult(shadow_modelViewMatrix, translate(-lightSource[0], -lightSource[1],-lightSource[2]));
					
					this.uniforms.u_modelViewMatrix = flatten(shadow_modelViewMatrix);
					this.uniforms.u_shadow = 1.0;
					this.uniforms.u_shadow_light_index = index;
					
					webglUtils.setUniforms(this.programInfo, this.uniforms);
					this.gl.drawArrays(this.gl.TRIANGLES, 0, this.bufferInfo.numElements);					
				}
			}
		}

		computeMatrix( translation, rotation, scale){
			var matrix = m4.identity();

			matrix = m4.translate(matrix,
			    translation[0],
			    translation[1],
			    translation[2]);

			matrix = m4.xRotate(matrix, rotation[0]);

			matrix = m4.yRotate(matrix, rotation[1]);

			matrix = m4.zRotate(matrix, rotation[2]);

			matrix = m4.scale(matrix,
				scale[0],
				scale[1],
				scale[2]);

			return matrix;
		}

		toggleAnimation(){
			this.enabled = !this.enabled;
		}
	}

	function main() {
		// Get A WebGL context
		/** @type {HTMLCanvasElement} */
		var canvas = document.getElementById("canvas");
		var gl = canvas.getContext("webgl");
		if (!gl) {
			return;
		}

		// setup GLSL program
		var programInfo = webglUtils.createProgramInfo(gl, ["3d-vertex-shader", "3d-fragment-shader"]);

		//objects = createObjects(gl,programInfo);
		scene = new Scene(gl,programInfo);
		scene.createObjects();

		requestAnimationFrame(render);

		function setLight1Tocamera() {
			lightPosition[0] = cameraPosition[0];
			lightPosition[1] = cameraPosition[1];
			lightPosition[2] = cameraPosition[2];
		}

		// Draw the scene.
		function render(time) {
			var t = time /1000;

			webglUtils.resizeCanvasToDisplaySize(gl.canvas);

			// Tell WebGL how to convert from clip space to pixels
			gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

			gl.enable(gl.CULL_FACE);
			gl.enable(gl.DEPTH_TEST);

			// Clear the canvas AND the depth buffer.
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

			// Compute the projection matrix
			projectionMatrix = getProjectionMatrix(gl);
			
			// Compute the camera's matrix using look at.
			cameraMatrix = m4.lookAt(cameraPosition, target, up);

			// Make a view matrix from the camera matrix.
			viewMatrix = m4.inverse(cameraMatrix);

			// ------ Draw Objects --------
			if(!paused){
				scene.render(time);
			}

			requestAnimationFrame(render);
		}


		var getProjectionMatrix = function(gl){
			var ret = setViewPerspective(gl);
			var elPers = document.getElementById("perspective") ;
			var elOrtho = document.getElementById("ortho") ;

			if(view == viewTypes['Perspective']){
				ret = setViewPerspective(gl);
				elPers.classList.add("active");
				elOrtho.classList.remove("active");
			}else{
				ret = setViewOrtho(gl);
				elPers.classList.remove("active");
				elOrtho.classList.add("active");
			}

			return ret;
		}

		var setViewOrtho = function (gl) {
			var near = -1;
			var far = 10000;
			var radius = 1.0;

			var target_width = 120.0 * orthoscale;
			var target_height = 200.0 * orthoscale;

			var A = target_width / target_height; // target aspect ratio 
			var V = gl.canvas.clientWidth / gl.canvas.clientHeight;


			var mat = [];

			// calculate V as above
			if (V >= A) {
			    // wide viewport, use full height
			    mat = m4.orthographic(-V/A * target_width/2.0, V/A * target_width/2.0, -target_height/2.0, target_height/2.0,  near, far);
			} else {
			    // tall viewport, use full width
			    mat = m4.orthographic(-target_width/2.0, target_width/2.0, -A/V*target_height/2.0, A/V*target_height/2.0,  near, far);
			}

			return mat;
		}

		var setViewPerspective = function (gl) {
			var fieldOfViewRadians = degToRad(60);
			var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
			return m4.perspective(fieldOfViewRadians, aspect, 1, 2000);
		}
	
		document.onkeydown = function(e) {
			var dir = [-cameraPosition[0]+target[0],
							-cameraPosition[1]+target[1],
							-cameraPosition[2]+target[2],
							0];

			var normDir = normalize(dir);

			if (e.which >= '1'.charCodeAt(0) && e.which <= '9'.charCodeAt(0)){
				scene.toggleAnimation(e.which-48);
			}
			else if (e.which == 'W'.charCodeAt(0)){ // Forward
				cameraPosition = vecAdd(cameraPosition,normDir);
				target = vecAdd(target,normDir);
				orthoscale *= .99; 
				//setLight1Tocamera();
				moveSpotLight(0,0);
			}
			else if (e.which == 'S'.charCodeAt(0)){ // Back
				cameraPosition = vecAdd(cameraPosition,multByScalar(normDir,-1));
				target = vecAdd(target,multByScalar(normDir,-1));
				orthoscale *= 1.01;
				//setLight1Tocamera(); 
				moveSpotLight(0,0);
			}
			else if (e.which == 'A'.charCodeAt(0)){ // left
				var newDir = rotateY(normDir,-0.2);
				target = vecAdd(cameraPosition,newDir);
				//setLight1Tocamera();
				moveSpotLight(0,0);
			}
			else if (e.which == 'D'.charCodeAt(0)){ // right
				var newDir = rotateY(normDir,0.2);
				target = vecAdd(cameraPosition,newDir);
				//setLight1Tocamera();
				moveSpotLight(0,0);
			}
			else if (e.which == 'E'.charCodeAt(0)){ // up
				var dirInCamerCoor = normalize(vecMatProduct(normDir,cameraMatrix));
				var newDirInCamerCoor = normalize(rotateX([dirInCamerCoor[0],dirInCamerCoor[1],dirInCamerCoor[2]],-0.2));
				var newDir = normalize(vecMatProduct(newDirInCamerCoor,m4.inverse(cameraMatrix)));
				if(newDir[1]<0.8){
					target = vecAdd(cameraPosition,newDir);
				}
				//setLight1Tocamera();
				moveSpotLight(0,0);
			}
			else if (e.which == 'Q'.charCodeAt(0)){ // down
				var dirInCamerCoor = normalize(vecMatProduct(normDir,cameraMatrix));
				var newDirInCamerCoor = normalize(rotateX([dirInCamerCoor[0],dirInCamerCoor[1],dirInCamerCoor[2]],0.2));
				var newDir = normalize(vecMatProduct(newDirInCamerCoor,m4.inverse(cameraMatrix)));
				if(newDir[1]>-0.8){
					target = vecAdd(cameraPosition,newDir);
				}
				//setLight1Tocamera();
				moveSpotLight(0,0);
			}
			else if (e.which == 'O'.charCodeAt(0)){
				console.log('Orthographic');
				view = viewTypes['Orthographic'];
			}
			else if (e.which == 'P'.charCodeAt(0)){
				console.log('Perspective');
				view = viewTypes['Perspective'];
			}
			else if (e.which == 'X'.charCodeAt(0)){
				var dis = document.getElementById("sidebar").style.display ;
				document.getElementById("sidebar").style.display = dis != "none" ? "none":"block";
			}
			else if (e.which == 'M'.charCodeAt(0)){
				lightPosition[0] += 10;
			}
			else if (e.which == 'B'.charCodeAt(0)){
				lightPosition[0] -= 10;
			}
			else if (e.which == 'H'.charCodeAt(0)){
				lightPosition[1] += 10;
			}
			else if (e.which == 'N'.charCodeAt(0)){
				lightPosition[1] -= 10;
			}
			else if (e.which == 'J'.charCodeAt(0)){
				lightPosition[2] += 10;
			}
			else if (e.which == 'G'.charCodeAt(0)){
				lightPosition[2] -= 10;
			}
			else if (e.which == 'Z'.charCodeAt(0)){
				lightPosition[0] = cameraPosition[0];
				lightPosition[1] = cameraPosition[1];
				lightPosition[2] = cameraPosition[2];
				console.log(cameraPosition,lightPosition);
			}
			else if(e.keyCode == 32){
				paused = !paused;
				var pause_screen = document.getElementById("pause_screen") ;

				if(paused){
					pause_screen.classList.remove("hidden");
				}else{
					pause_screen.classList.add("hidden");
				}
			}
			else if(e.keyCode == 38){
				spotlightInnerLimit = Math.max(0.4,spotlightInnerLimit-0.005)
				spotlightOuterLimit = Math.max(0.2,spotlightOuterLimit-0.005)
			}
			else if(e.keyCode == 40){
				spotlightInnerLimit = Math.min(0.999,spotlightInnerLimit+0.005)
				spotlightOuterLimit = Math.min(0.95,spotlightOuterLimit+0.005)
			}
		};

		document.onmousemove = function( event ) {
			moveSpotLight((event.pageX/gl.canvas.clientWidth - 0.5)*3.14/4, (event.pageY/gl.canvas.clientHeight-0.5)*3.14/4);
		};

		var moveSpotLight = function (diffX, diffY) {
			var dir = [-cameraPosition[0]+target[0],
							-cameraPosition[1]+target[1],
							-cameraPosition[2]+target[2],
							0];

			var normDir = normalize(dir);

			var diff = [diffX,diffY];
			var dirInCamerCoor = normalize(vecMatProduct(normDir,cameraMatrix));

			var newDirInCamerCoor = rotateX([dirInCamerCoor[0],dirInCamerCoor[1],dirInCamerCoor[2]],diff[1]);
			var newDirInCamerCoor = rotateY([newDirInCamerCoor[0],newDirInCamerCoor[1],newDirInCamerCoor[2]],diff[0]);
			var newDir = normalize(vecMatProduct(newDirInCamerCoor,m4.inverse(cameraMatrix)));

			console.log("CamerDir:",normDir);
			console.log("dirInCamerCoor:",dirInCamerCoor);
			console.log("diff:",diff);
			console.log("CamerDir:",newDir);
			console.log("===================================");

			lightDirection[3] = [newDir[0],newDir[1],newDir[2]];
			lightPosition[3] = [cameraPosition[0], cameraPosition[1], cameraPosition[2], 0.0] ;
		}
	}

	window.onload = main();

</script>
</body>
</html>