<!DOCTYPE html>
<html>
<head>
	<title>WebGL Transformations, Navigation and Projections</title>
	<style type="text/css">
		@import url("https://webglfundamentals.org/webgl/resources/webgl-tutorials.css");
		body {
		  margin: 0;
		}
		canvas {
		  width: 100vw;
		  height: 100vh;
		  display: block;
		  cursor: none; 
		}
		#sidebar{
			height: 100%;
			width: 400px;
			position:fixed;
			top:0px;
			right: 0px;
			background-color: #ffffffe8;
			border: 1px #989898 solid;
			font-size:1.2em;
			text-align: center;
			overflow: scroll;
			line-height: 1.4em;
		}
		.key{
			color: #34a21a;
			font-weight: 700;
		}
		.active{
			font-weight: 900;
		}
		.hidden{
			display: none;
		}
		#pause-screen{
			width: 100%;
			height: 100%;
			position: fixed;
			left: 0;
			top: 0;
			text-align: center;
			color: #FFFFFA;
			background: #6b6971;
			font-size: 3em;
			font-family: sans-serif;
		}
		.pause-title{ 
			position: absolute;
			left: 0;
			right: 0;
			top: 40%;
		}	
		.light-intensity-title, .material-properties-title{
			margin-left: 20px;
			vertical-align: top;
			width: 40%;
			display: inline-block;
		}
		.slider {
			-webkit-appearance: none;
			width: 40%;
			height: 25px;
			background: #d3d3d3;
			outline: none;
			opacity: 0.7;
			-webkit-transition: .2s;
			transition: opacity .2s;
		}
		.slider:hover {
			opacity: 1;
		}
		.slider::-webkit-slider-thumb {
			-webkit-appearance: none;
			appearance: none;
			width: 25px;
			height: 25px;
			background: #4CAF50;
			cursor: pointer;
		}
		.slider::-moz-range-thumb {
			width: 25px;
			height: 25px;
			background: #4CAF50;
			cursor: pointer;
		}
	</style>
</head>
<body>
<div id="pause-screen" class="hidden"><h1 class="pause-title">Press Space To Continue!</h1></div>
<canvas id="canvas"></canvas>
<div id="sidebar" style="">
	<h4>WebGL Transformations, Navigation and Projections</h4>
	<span class="action"><span class="key">W - S</span>  Move Forwards / Backwards</span>
	<br>
	<br>
	<span class="action"><span class="key">A - D</span>  Turn Left / Right</span>
	<br>
	<br>
	<span class="action"><span class="key">E - Q</span>  Look Up / Down</span>
	<br>
	<br>
	<span class="action"><span class="key">1 - 5</span>  Toggle Shapes (1-5) Animations </span>
	<br>
	<br>
	<span class="action"><span class="key">O - P</span>  <span id="ortho">Orthographic</span> / <span id="perspective" class="active">Perspective</span> </span>
	<br>
	<br>
	<span class="action"><span class="key">F</span>  <span class="shading active">Smooth</span> / <span class="shading">Flat</span> / <span class="shading">Cell</span> Shading</span>
	<br>
	<br>
	<span class="action"><span class="key">Space</span> Pause Scene</span>
	<br>	
	<br>
	<span class="action"><span class="key">Up - Down</span> Spotlight Radius</span>
	<br>
	<div style="text-align: left;">
		<h4 style="text-align: center;">Light Intensities:</h4>
		<span class="light-intensity-title">Moving Light:</span><input type="range" min="0.0" max="2.0" value="1.0" step="0.1" class="slider lightIntensitySlider">
		<br>
		<br>
		<span class="light-intensity-title">Right:</span><input type="range" min="0.0" max="2.0" value=".2" step="0.1" class="slider lightIntensitySlider">
		<br>
		<br>
		<span class="light-intensity-title">Center:</span><input type="range" min="0.0" max="2.0" value=".2" step="0.1" class="slider lightIntensitySlider">
		<br>
		<br>
		<span class="light-intensity-title">Left:</span><input type="range" min="0.0" max="2.0" value=".2" step="0.1" class="slider lightIntensitySlider">
		<br>
		<br>
		<span class="light-intensity-title">Spotlight:</span><input type="range" min="0.0" max="3.0" value=".3" step="0.1" class="slider lightIntensitySlider">
	</div>
	<div style="text-align: left;">
		<h4 style="text-align: center;">Light Proprties - <span id="selected-light-label"></span></h4>
		<span class="light-intensity-title">Choose Light:</span><input type="range" min="0" max="4" value="0" step="1" class="slider lightSelectionSlider" id="light-selection-slider">
		<br>
		<br>
		<span class="light-intensity-title">Specular:</span><input type="range" min="0.0" max="2.0" value="" step="0.1" class="slider lightPropertiesSlider" id="specular-intensity-slider">
		<br>
		<br>
		<span class="light-intensity-title">Diffuse:</span><input type="range" min="0.0" max="2.0" value="" step="0.1" class="slider lightPropertiesSlider" id="diffuse-intensity-slider">
		<br>
		<br>
		<span class="light-intensity-title">Ambient:</span><input type="range" min="0.0" max="2.0" value="" step="0.1" class="slider lightPropertiesSlider" id="ambient-intensity-slider">
		<br>
		<br>
		<span class="light-intensity-title">Red:</span><input type="range" min="0.0" max="2.0" value="" step="0.1" class="slider lightPropertiesSlider" id="red-intensity-slider">
		<br>
		<br>
		<span class="light-intensity-title">Green:</span><input type="range" min="0.0" max="2.0" value="" step="0.1" class="slider lightPropertiesSlider" id="green-intensity-slider">
		<br>
		<br>
		<span class="light-intensity-title">Blue:</span><input type="range" min="0.0" max="2.0" value="" step="0.1" class="slider lightPropertiesSlider" id="blue-intensity-slider">
	</div>
	<br>
	<br>
	<div style="text-align: left;">
		<h4 style="text-align: center;">Material Proprties - <span id="selected-shape-label"></span></h4>
		<span class="material-properties-title">Choose Shape:</span><input type="range" min="0" max="5" value="0" step="1" class="slider shapeSelectionSlider" id="shape-selection-slider">
		<br>
		<br>
		<span class="material-properties-title">Specular:</span><input type="range" min="0.0" max="2.0" value="" step="0.1" class="slider materialPropertySlider" id="specular-property-slider">
		<br>
		<br>
		<span class="material-properties-title">Diffuse:</span><input type="range" min="0.0" max="2.0" value="" step="0.1" class="slider materialPropertySlider" id="diffuse-property-slider">
		<br>
		<br>
		<span class="material-properties-title">Ambient:</span><input type="range" min="0.0" max="2.0" value="" step="0.1" class="slider materialPropertySlider" id="ambient-property-slider">
		<br>
		<br>
		<span class="material-properties-title">Shineness:</span><input type="range" min="0.0" max="2000.0" value="" step="10" class="slider materialPropertySlider" id="shineness-property-slider">
		<br>
		<br>
		<span class="material-properties-title">Red:</span><input type="range" min="0.0" max="2.0" value="" step="0.1" class="slider materialPropertySlider" id="red-property-slider">
		<br>
		<br>
		<span class="material-properties-title">Green:</span><input type="range" min="0.0" max="2.0" value="" step="0.1" class="slider materialPropertySlider" id="green-property-slider">
		<br>
		<br>
		<span class="material-properties-title">Blue:</span><input type="range" min="0.0" max="2.0" value="" step="0.1" class="slider materialPropertySlider" id="blue-property-slider">
	</div>
	<br>
	<br>
	<span class="action"><span class="key">X</span> Show / Hide Sidebar</span>
	<br>
	<br>
	<span style="font-size: 0.6em;">Made By <a href="mailto:m_abdulhak@outlook.com">Mohammed Abdullhak</a></span>
	<br>
	<br>
	<span style="font-size: 0.6em;"><a href="https://github.com/m-abdulhak/WebGLTransformations">Source Code</a></span>
</div>

<!-- vertex shader -->
<script  id="3d-vertex-shader" type="x-shader/x-vertex">
varying vec3 vertex_view_space;

attribute vec4 a_position;
attribute vec4 a_normal;
attribute vec4 a_color;

uniform mat4 u_matrix;
uniform mat4 u_modelViewMatrix;
uniform mat4 u_projectionMatrix;

uniform vec3 u_viewWorldPosition;

uniform vec4 u_lightPositions[5];

varying vec3 v_normal;
varying vec3 v_surfaceToLight[5];
varying vec3 v_surfaceToView;
varying vec4 v_face_color;


void main() {
	// For flat shading
	vertex_view_space = ( u_modelViewMatrix * u_matrix * a_position).xyz;  

	// Multiply the position by the matrix.
	gl_Position = u_projectionMatrix * u_modelViewMatrix * u_matrix * a_position;

	// orient the normals and pass to the fragment shader
	v_normal = mat3(u_matrix) * a_normal.xyz;

	// compute the world position of the surfoace
	vec3 surfaceWorldPosition = (u_matrix * a_position).xyz;

	// compute the vector of the surface to the light
	// and pass it to the fragment shader	
	for(int i = 0; i < 5; i++) {
		v_surfaceToLight[i] = u_lightPositions[i].xyz - surfaceWorldPosition;
	}

	// compute the vector of the surface to the view/camera
	// and pass it to the fragment shader
	v_surfaceToView = u_viewWorldPosition - surfaceWorldPosition;
	
	// Pass face normal to the fragment shader for flat shading
	//f_normal = a_normal;

	// Pass face color to the fragment shader for simple shading
	v_face_color = a_color;
}
</script>

<!-- fragment shader -->
<script  id="3d-fragment-shader" type="x-shader/x-fragment">
precision mediump float;

#extension GL_OES_standard_derivatives : enable

varying vec3 vertex_view_space;

uniform vec4 u_surfaceColor;
uniform float u_shininess;
uniform float u_shadow;
uniform int u_shadow_light_index;
uniform float u_spotlightInnerLimit;
uniform float u_spotlightOuterLimit;
uniform int u_shading_mode;

uniform highp vec4 u_lightPositions[5];
uniform highp vec3 u_lightDirections[5];

uniform vec3 u_ambientColors[5];
uniform vec3 u_diffuseColors[5];
uniform vec3 u_specularColors[5];

// Passed in from the vertex shader.
varying vec3 v_normal;
varying vec3 v_surfaceToLight[5];
varying vec3 v_surfaceToView;
varying vec4 v_face_color;

void main() {
	// because v_normal is a varying it's interpolated
	// so it will not be a unit vector. Normalizing it
	// will make it a unit vector again
	vec3 surfaceNormal = normalize(v_normal);

	if(u_shading_mode == 1){
		vec3 U = dFdx(vertex_view_space);                     
		vec3 V = dFdy(vertex_view_space);                 
		surfaceNormal = normalize(cross(U,V));
	}

	gl_FragColor = u_surfaceColor;

	if(u_shading_mode < 2){
		vec3 diffusedLights = vec3(0.0, 0.0, 0.0);
		vec3 specularLights = vec3(0.0, 0.0, 0.0);
		vec3 ambientLights = vec3(0.0, 0.0, 0.0);

		for(int i = 0; i < 5; i++) {
			vec3 surfaceToLightDirection = normalize(v_surfaceToLight[i]);
			vec3 surfaceToViewDirection = normalize(v_surfaceToView);
			vec3 halfVector = normalize(surfaceToLightDirection + surfaceToViewDirection);

			float light = dot(surfaceNormal, surfaceToLightDirection);

			float coef = 1.0;

			if(u_lightPositions[i].a == 0.0){
				// check if current position is within spotlight limit 
				vec3 lightDirectionsNorm = normalize(u_lightDirections[i]);
				float dotFromDirection = dot(surfaceToLightDirection,-u_lightDirections[i]);

				coef = smoothstep(u_spotlightOuterLimit, u_spotlightInnerLimit, dotFromDirection);;
			}

			float specular = 0.0;
			if (light > 0.0) {
				specular = pow(dot(surfaceNormal, halfVector), u_shininess);
			}

			// Lets multiply just the color portion (not the alpha)
			// by the light
			diffusedLights.rgb += light * u_diffuseColors[i] * coef;

			// Just add in the specular
			specularLights.rgb += specular * u_specularColors[i] * coef;

			// Add ambientColor
			ambientLights.rgb += u_ambientColors[i] * coef;
			
			// TODO: remove ambient light of current light under its shadow
			// this does not work, causes flickering if overlaping with other shadows
			//if(u_shadow==1.0  && u_shadow_light_index == i){
				//ambientLights.rgb -= u_ambientColors[i];
			//}
		}
		
		gl_FragColor.rgb *= diffusedLights ;

		// Just add in the specular
		gl_FragColor.rgb += specularLights;

		// Add ambientColor
		gl_FragColor.rgb += ambientLights;
		
		// if redndering a shoadow only keep ambientLights
		if(u_shadow==1.0){
			gl_FragColor = vec4(.1, .1, .1, .2);
			gl_FragColor.rgb += ambientLights;
		}
	} else if (u_shading_mode == 2){
		gl_FragColor *= v_face_color;
	}
}
</script>
<script src="common/webgl-utils.js"></script>
<script src="common/m4.js"></script>
<script src="common/primitives.js"></script>
<script type="text/javascript" src="common/MV.js"></script>

<script type="text/javascript">
	"use strict";

	var scene;
	var paused = false;
	var shadingMode = 0;

	var cameraPosition = [70, 70, 220];
	var target = [cameraPosition[0], cameraPosition[1], cameraPosition[2]-1];
	var up = [0, 100, 0];
	var cameraMatrix = [];
	var viewMatrix = [];
	var projectionMatrix = [];
	var orthoscale = 1;
	
	var viewTypes = {'Orthographic':0,'Perspective':1};
	var view = viewTypes['Perspective'];
		
	// My Lighting 
	// Lighting
	// vec4
	// TODO: Refactor into class
	var lightPosition = [	[70, 70, 40, 1.0 ], 
							[140, 140, 80, 1.0 ], 
							[70, 140, 80, 1.0 ], 
							[0, 140, 80, 1.0 ], 
							[70, 70, 220, 0.0 ]];

	var lightDirection = [	[0.0, 0.0, 0.0], 
							[0.0, 0.0, 0.0], 
							[0.0, 0.0, 0.0], 
							[0.0, 0.0, 0.0], 
							[0., 0., -1.0]];

	var lightColorBase = [	[1.0, 1.0, 1.0], 
							[.9, .2, .2], 
							[.2, .2, .9], 
							[.2, .9, .2], 
							[1.0, 1.0, 1.0]];

	var lightColor = [...lightColorBase];
	
	// Specular, Diffuse, Ambient Intensities
	var lightProperties = [	[1.0, 0.5, 0.05], 
							[0.7, 0.3, 0.05], 
							[0.7, 0.3, 0.05], 
							[0.7, 0.3, 0.05], 
							[1.0, 0.5, 0.05]];
	
	var lightSpecular = [multByScalar(lightColor[0], lightProperties[0][0]), multByScalar(lightColor[1], lightProperties[1][0]), multByScalar(lightColor[2], lightProperties[2][0]), multByScalar(lightColor[3], lightProperties[3][0]), multByScalar(lightColor[4], lightProperties[4][0])];
	var lightDiffuse = [multByScalar(lightColor[0], lightProperties[0][1]), multByScalar(lightColor[1], lightProperties[1][1]), multByScalar(lightColor[2], lightProperties[2][1]), multByScalar(lightColor[3], lightProperties[3][1]), multByScalar(lightColor[4], lightProperties[4][1])];
	var lightAmbient = [multByScalar(lightColor[0], lightProperties[0][2]), multByScalar(lightColor[1], lightProperties[1][2]), multByScalar(lightColor[2],lightProperties[2][2]), multByScalar(lightColor[3], lightProperties[3][2]), multByScalar(lightColor[4], lightProperties[4][2])];
	
	var spotlightOuterLimit = 0.8;
	var spotlightInnerLimit = 0.9;

	// Shadows
	var xyPlaneShadowsTransformationMatrix = [];

	function copyOf(obj) {
		return JSON.parse(JSON.stringify(obj));		
	}

	function degToRad(d){

	    return d * Math.PI / 180;
	}

	function vecAdd(v1,v2){
		var resV = [];
		for (var i = 0; i < v1.length; i++) {
			resV[i] = v1[i]+v2[i];
		}
		return resV;
	}

	function multByScalar(v1,scalar) {
		var resV = [];
		for (var i = 0; i < v1.length; i++) {
			resV[i] = v1[i]*scalar;
		}
		return resV;
	}

	function vecMatProduct(vec,mat){
		if(vec.length<4)
			vec.push(0);

		var result = [ 
		vec[0]*mat[0]+vec[1]*mat[1]+vec[2]*mat[2]+vec[3]*mat[3],
		vec[0]*mat[4+0]+vec[1]*mat[4+1]+vec[2]*mat[4+2]+vec[3]*mat[4+3],
		vec[0]*mat[8+0]+vec[1]*mat[8+1]+vec[2]*mat[8+2]+vec[3]*mat[8+3],
		vec[0]*mat[12+0]+vec[1]*mat[12+1]+vec[2]*mat[12+2]+vec[3]*mat[12+3]
		];


		return result;
	}

	function normalize(dir){
		var length = Math.sqrt(dir[0]*dir[0]+dir[1]*dir[1]+dir[2]*dir[2]);
		var normalized = [dir[0]/length,dir[1]/length,dir[2]/length];
		normalized = dir.length == 4 ? normalized.concat(dir[3]) : normalized;

		return length != 0 ? normalized : dir;
	}

	function rotateZ(vec, theta){
		var cos = Math.cos(theta);
		var sin = Math.sin(theta);

		return [	vec[0]*cos+vec[1]*sin,
					-vec[0]*sin+vec[1]*cos,
					vec[2]
					];
	}

	function rotateY(vec, theta){
		var cos = Math.cos(theta);
		var sin = Math.sin(theta);

		return [	vec[0]*cos-vec[2]*sin,
					vec[1],
					vec[0]*sin+vec[2]*cos
					];
	}

	function rotateX(vec, theta){
		var cos = Math.cos(theta);
		var sin = Math.sin(theta);

		return [	vec[0],
					vec[1]*cos+vec[2]*sin,
					-vec[1]*sin+vec[2]*cos
					];
	}

	class ShapeFactory {
		constructor (gl,programInfo){
		this.gl = gl;
		this.programInfo = programInfo;

		// Consts
		this.DefShapeSettings = {
			position : [0,0,0],
			speed : [0,0,0],
			positionLimits : {
						"Max" : [1000, 1000, 1000],
						"Min" : [-1000, -1000,-1000]
			},
			orientation : [0,0,0],
			angularSpeed : [0,0,0],
			size : [1,1,1],
			sizeChangeRate : [1,1,1],	
			scaleLimit: [2,2,2],			
			material: {	"materialAmbient" : [ 1.0, 1.0, 1.0 ],
				"materialDiffuse" : [ 1.0, 1.0, 1.0 ],
				"materialSpecular" : [ .3, .3, .3 ],
				"materialShininess" : 5.0},
			hasShadow:true,
			isLight: false};

		this.Shapes = {
			"Plane" : primitives.createCubeVertices(20),
			"Sphere" : primitives.createSphereVertices(10, 60, 60),
			"Cube" : primitives.createCubeVertices(20),
			"Pyramid" : primitives.createTruncatedConeVertices(10, 0, 20, 30, 10, true, true),
			"Cylinder" : primitives.createTruncatedConeVertices(10, 10, 20, 60, 1, true, true),
			"Cone" : primitives.createTruncatedConeVertices(10, 0, 20, 60, 1, true, true)};
		this.Colors = {
			"Red" : [1, 0.1, 0.1, 1],
			"Green" : [0.1, 1, 0.1, 1],
			"Blue" : [0.3, 0.3, 1, 1],
			"Yellow" : [1, 1, 0.1, 1],
			"Magneta" : [1, 0.1, 1, 1],
			"Gray" : [0.3, 0.3, 0.3, 1],
			"Black" : [0.1, 0.1, 0.1, 1],
			"White" : [1.0, 1.0, 1.0, 1.0],
			"Glowing" : [1, 1, 1, 1]};
		this.Materials = {
			"Matt" : {	"materialAmbient" : [ 1.0, 1.0, 1.0 ],
				"materialDiffuse" : [ 1.0, 1.0, 1.0 ],
				"materialSpecular" : [ 0.5, 0.5, 0.5 ],
				"materialShininess" : 5.0},
			"Shiny" : {	"materialAmbient" : [ 1.0, 1.0, 1.0 ],
				"materialDiffuse" : [ 1.0, 1.0, 1.0 ],
				"materialSpecular" : [ 1.0, 1.0, 1.0 ],
				"materialShininess" : 10.0},
			"Mirror" : {	"materialAmbient" : [ 1.0, 1.0, 1.0 ],
				"materialDiffuse" : [ 0.8, 0.8, 0.8 ],
				"materialSpecular" : [ 1.0, 1.0, 1.0 ],
				"materialShininess" : 10000.0},
			"Light" : {	"materialAmbient" : [ 100.0, 100.0, 100.0 ],
				"materialDiffuse" : [ 1.0, 1.0, 1.0 ],
				"materialSpecular" : [ 100.0, 100.0, 100.0 ],
				"materialShininess" : 1.0}						
			};
			this.DefaultColor = this.Colors.Red;
		}

		getDefaultsWith(parObject){
			var settings = {...this.DefShapeSettings};
			
			for (var k in parObject) {
				if (parObject.hasOwnProperty(k)) {
					settings[k] = parObject[k];
				}
			}
			//console.log(parObject,settings)
			return settings;
		}
		
		createShape = function(shape, location, color, parameters) {
			// print shpae info
			//console.log(shape);
			const settings = parameters == null? copyOf(this.DefShapeSettings) : copyOf(parameters);
			const col = color == null? this.defaultColor : color;
			const loc = location;

			return new WebGlObject(
				this.gl,
				this.programInfo,
				shape,
				col,
				loc,
				settings.speed,
				settings.positionLimits,
				settings.orientation,
				settings.angularSpeed,
				settings.size,
				settings.sizeChangeRate,
				settings.scaleLimit,	
				settings.material.materialAmbient,
				settings.material.materialDiffuse,
				settings.material.materialSpecular,
				settings.material.materialShininess,
				settings.hasShadow,
				settings.isLight,		
				settings.lightIndex,
				settings.name);
		}
	}

	class Scene{
		constructor(gl,programInfo){
			this.gl = gl;
			this.programInfo = programInfo;
			this.ShapeFactory = new ShapeFactory(gl,programInfo);
			this.Positions = {
				"Center" : [2.5,2.5,0.8],
				"TopLeft" : [1,4,0.8],
				"TopRight" : [4,4,0.8],
				"BottomLeft" : [1,1,0.8],
				"BottomRight" : [4,1,0.8]};
			this.objects = [];
		}

		getPosition(position){
			const stepSize = [30, 30, 30];
			return [position[0]*stepSize[0],position[1]*stepSize[1],position[2]*stepSize[2]];
		}

		createObjects (){
			var sF = this.ShapeFactory;

			var position = this.getPosition(this.Positions.Center);
			position[2]=-1.1;
			var parameters = sF.getDefaultsWith({"name": "Plane", "size":[50,50,.1], "scaleLimit": [100,100,100], "material": sF.Materials.Mirror, "hasShadow": false});
			this.objects.push(sF.createShape(sF.Shapes.Plane,position,sF.Colors.Gray,parameters));

			position = this.getPosition(this.Positions.TopLeft);
			parameters = sF.getDefaultsWith({"name": "Cube","angularSpeed":[.1,.1,0]});
			this.objects.push(sF.createShape(sF.Shapes.Cube,position,sF.Colors.Red,parameters));
			
			position = this.getPosition(this.Positions.TopRight);
			parameters = sF.getDefaultsWith({"name": "Pyramid", "speed":[1,1,0], "positionLimits" : {"Max": [140, 140,1000] , "Min": [100, 100,-1000]}, "angularSpeed":[-1,-1,-1],"sizeChangeRate":[1.1,1.005,1.005],"scaleLimit":[2,2,2], "material": sF.Materials.Shiny});
			this.objects.push(sF.createShape(sF.Shapes.Pyramid,position,sF.Colors.Yellow,parameters));

			position = this.getPosition(this.Positions.Center);
			parameters = sF.getDefaultsWith({"name": "Sphere", "speed":[10,0,0], "positionLimits" : {"Max": [120,70,1000] , "Min": [20,40,-1000]}, "material": sF.Materials.Shiny});
			this.objects.push(sF.createShape(sF.Shapes.Sphere,position,sF.Colors.Green,parameters));


			position = this.getPosition(this.Positions.BottomLeft);
			parameters = sF.getDefaultsWith({"name": "Cylinder", "sizeChangeRate":[1.001,1.001,1.001], "scaleLimit": [1.2,1.2,1.2], "material": sF.Materials.Shiny});
			this.objects.push(sF.createShape(sF.Shapes.Cylinder,position,sF.Colors.Blue,parameters));

			position = this.getPosition(this.Positions.BottomRight);
			parameters = sF.getDefaultsWith({"name": "Cone", "sizeChangeRate":[0.999,0.998,0.997], "scaleLimit": [1.2,1.2,1.2]});
			this.objects.push(sF.createShape(sF.Shapes.Cone,position,sF.Colors.Magneta,parameters));

			// Attach lights
			position = [100,100,60];
			parameters = sF.getDefaultsWith({"size":[.1,.1,.1], "scaleLimit": [10000,10000,10000], "speed":[10,20,0], "positionLimits" : {"Max": [140, 140,1000] , "Min": [0, 0,-1000]}, "material": sF.Materials.Light , "isLight": true, "lightIndex": 1, "hasShadow": false});
			this.objects.push(sF.createShape(sF.Shapes.Sphere,position,sF.Colors.Glowing,parameters));
		}

		render(time){
			var t = time /1000;
			for(const o of this.objects){
				o.update(time);
				o.draw(t);
			}
		}

		toggleAnimation(objIndex){
			this.objects[objIndex].toggleAnimation();
		}			
	}

	class WebGlObject {
		constructor(gl, 
					programInfo, 
					vertices, 
					color, 
					position=[0,0,0], 
					speed=[0,0,0], 
					positionLimits = {
						"Max" : [1000, 1000, 1000],
						"Min" : [-1000, -1000,-1000]
					},
					orientation=[0,0,0], 
					orientationChangeRate=[0,0,0],
					size=[1,1,1],  
					sizeChangeRate=[1,1,1], 
					scaleLimit=[10,10,10],			
					materialAmbient = [ 1.0, 1.0, 1.0 ],
					materialDiffuse = [ 1.0, 1.0, 1.0 ],
					materialSpecular = [ 1.0, 1.0, 1.0 ],
					materialShininess = 20.0,
					hasShadow = true,
					isLight = false,
					lightIndex,
					name) {

			this.gl = gl;
			this.programInfo = programInfo;
			
			// Contains vertices' positions, normals, texcoords, and indices
			this.vertices = vertices;
			//console.log("vertices:",vertices);

			this.color = color;
			this.name = name;

			this.bufferInfo = this.flattenedVertices();
			this.uniforms = {	u_surfaceColor: color,
							};
			this.position = position;
			this.positionLimits = positionLimits;
			this.rotation = orientation;
			this.scale = size;
			this.speed = speed;
			this.orientationChangeRate = orientationChangeRate;
			this.sizeChangeRate = sizeChangeRate;
			this.time = 0;
			this.scaleLimit = scaleLimit;

			this.translation = this.position;
			this.enabled = true;

			// material properties
			this.materialAmbient = materialAmbient;
			this.materialDiffuse = materialDiffuse;
			this.materialSpecular = materialSpecular;
			this.materialShininess = materialShininess;

			// Shadow
			this.hasShadow = hasShadow;
			
			// lighting
			this.isLight = isLight;
			this.lightIndex = lightIndex;

			// print buffer info
			//console.log(this.bufferInfo);
			//console.log(this);
		}

		flattenedVertices() {
			return webglUtils.createBufferInfoFromArrays(
			    this.gl,
			    primitives.makeRandomVertexColors(
			        primitives.deindexVertices(this.vertices),
			        {
			          vertsPerColor: 6,
			          rand: function(ndx, channel) {
			            return channel < 3 ? ((128 + Math.random() * 128) | 0) : 255;
			          }
			        })
			);
		}

		update(time){
			const delta = (time - this.time)/1000;
			this.time = time;

			this.position = this.simulate(this.position,this.speed,delta);
			this.bounce(this.position,this.speed, this.positionLimits.Max,this.positionLimits.Min);
			this.translation = [this.position[0],this.position[1],this.position[2]];

			this.rotation = this.simulate(this.rotation,this.orientationChangeRate,delta);
			
			this.scale = this.simulateSize(this.scale,this.sizeChangeRate,delta);
			this.bounceScale(this.scaleLimit);
		}

		simulate(vector,changeRate,timeDelta){
			if(this.enabled){
				if(this.isLight) {
					lightPosition[this.lightIndex] = this.position;
					lightPosition[this.lightIndex][3] = 1;
					//console.log('islight:',this.isLight,this.position,lightPosition)
				}
				return vecAdd(vector,multByScalar(changeRate,timeDelta));
			}
			else{
				return vector;
			}
		}

		simulateSize(vector,changeRate,timeDelta){
			return this.enabled? mult(vector,changeRate):vector;
		}

		bounce(vector,changeRate,limitsHigh,limitsLow){
			for (var i = 0; i < vector.length; i++) {
				if(vector[i]>limitsHigh[i]){
					changeRate[i] = -1* changeRate[i];
					vector[i] = limitsHigh[i];
				}
				if(vector[i]<limitsLow[i]){
					changeRate[i] = -1* changeRate[i];
					vector[i] = limitsLow[i];
				}
			}
		}

		bounceScale(limits){
			var vector = this.scale;

			for (var i = 0; i < vector.length; i++) {
				if(vector[i]>limits[i]){
					this.sizeChangeRate[i] = 1/this.sizeChangeRate[i];
					vector[i] = limits[i];
				} else if(vector[i]<1/limits[i]){
					this.sizeChangeRate[i] = 1/this.sizeChangeRate[i];
					vector[i] = 1/limits[i];				
				}
			}
		}

		limitVector(vector,limits){
			var newVec = [];
			for (var i = 0; i < vector.length; i++) {
				newVec[i] = vector[i] % limits[i];
			}
			return newVec;
		}

		draw(time){

			this.gl.useProgram(this.programInfo.program);

			// Setup all the needed attributes.
			webglUtils.setBuffersAndAttributes(this.gl, this.programInfo, this.bufferInfo);

			this.uniforms.u_matrix = this.computeMatrix(
			    this.translation,
			    this.rotation,
				this.scale);

			var transfMatrix = this.computeMatrix(
				m4.identity(),
			    [0,0,0],
			    this.rotation,
				this.scale);
				
			this.uniforms.u_shading_mode = shadingMode;
			this.uniforms.u_transformation_matrix = transfMatrix;
			this.uniforms.u_modelViewMatrix = viewMatrix;
			this.uniforms.u_projectionMatrix = projectionMatrix;
			this.uniforms.u_viewWorldPosition = cameraPosition;

			var ambientProduct = [];
			var diffuseProduct = [];
			var specularProduct = [];

			// Update my lighting parameters
			for (let index = 0; index < lightAmbient.length; index++) {
				ambientProduct[index] = mult(lightAmbient[index], this.materialAmbient);
				diffuseProduct[index] = mult(lightDiffuse[index], this.materialDiffuse);
				specularProduct[index] = mult(lightSpecular[index], this.materialSpecular);
			}
					
			this.uniforms.u_shininess = this.materialShininess;

			this.uniforms.u_shadow = 0.0;
			this.uniforms.u_spotlightInnerLimit = spotlightInnerLimit;
			this.uniforms.u_spotlightOuterLimit = spotlightOuterLimit;

			var lightPositionsLocation = this.gl.getUniformLocation(this.programInfo.program, "u_lightPositions");
			this.gl.uniform4fv(lightPositionsLocation,flatten(lightPosition));
			var lightDirectionLocation = this.gl.getUniformLocation(this.programInfo.program, "u_lightDirections");
			this.gl.uniform3fv(lightDirectionLocation,flatten(lightDirection));
			var ambientProductLocation = this.gl.getUniformLocation(this.programInfo.program, "u_ambientColors");
			this.gl.uniform3fv(ambientProductLocation,flatten(ambientProduct));
			var diffuseProductLocation = this.gl.getUniformLocation(this.programInfo.program, "u_diffuseColors");
			this.gl.uniform3fv(diffuseProductLocation,flatten(diffuseProduct));
			var specularProductLocation = this.gl.getUniformLocation(this.programInfo.program, "u_specularColors");
			this.gl.uniform3fv(specularProductLocation,flatten(specularProduct));

			// Set the uniforms we just computed
			webglUtils.setUniforms(this.programInfo, this.uniforms);

			this.gl.depthMask(true);
			this.gl.drawArrays(this.gl.TRIANGLES, 0, this.bufferInfo.numElements);
			this.gl.depthMask(false);

			if(this.hasShadow && shadingMode<2){
				this.gl.enable(this.gl.BLEND);
				this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.DST_COLOR);

				for (let index = 0; index < lightPosition.length; index++) {
					// if light is very dim do not render its shadow
					// reduce function returns the summ of RGB intensities
					if(lightColor[index].reduce((a,b) => a + b, 0) < 0.1 || lightPosition[index][2] < 0)
						continue;

					// model-view matrix for shadow then render
					var black = vec4(0.0, 0.0, 0.0, 1.0);
					var lightSource = lightPosition[index];
					var para1 = translate(lightSource[0], lightSource[1], lightSource[2]);
					var src = viewMatrix;
					para1[0] = [src[0],src[4],src[8],src[12]];
					para1[1] = [src[1],src[5],src[9],src[13]];
					para1[2] = [src[2],src[6],src[10],src[14]];
					para1[3] = [src[3],src[7],src[11],src[15]];
					var para2 = translate(lightSource[0], lightSource[1], lightSource[2]);
					var shadow_modelViewMatrix = mult(para1, para2);

					xyPlaneShadowsTransformationMatrix[index] = mat4();
					xyPlaneShadowsTransformationMatrix[index][3][3] = 0;
					xyPlaneShadowsTransformationMatrix[index][3][2] = -1/lightPosition[index][2];
	
					//console.log("modelViewMatrix:",para1,"translate:",para2,"modelViewMatrix",shadow_modelViewMatrix)
					shadow_modelViewMatrix = mult(shadow_modelViewMatrix, xyPlaneShadowsTransformationMatrix[index]);
					shadow_modelViewMatrix = mult(shadow_modelViewMatrix, translate(-lightSource[0], -lightSource[1],-lightSource[2]));
					
					this.uniforms.u_modelViewMatrix = flatten(shadow_modelViewMatrix);
					this.uniforms.u_shadow = 1.0;
					this.uniforms.u_shadow_light_index = index;
					
					webglUtils.setUniforms(this.programInfo, this.uniforms);
					this.gl.drawArrays(this.gl.TRIANGLES, 0, this.bufferInfo.numElements);					
				}
				//this.gl.enable(this.gl.DEPTH_TEST);
				this.gl.disable(this.gl.BLEND);
			}
		}

		computeMatrix( translation, rotation, scale){
			var matrix = m4.identity();

			matrix = m4.translate(matrix,
			    translation[0],
			    translation[1],
			    translation[2]);

			matrix = m4.xRotate(matrix, rotation[0]);

			matrix = m4.yRotate(matrix, rotation[1]);

			matrix = m4.zRotate(matrix, rotation[2]);

			matrix = m4.scale(matrix,
				scale[0],
				scale[1],
				scale[2]);

			return matrix;
		}

		toggleAnimation(){
			this.enabled = !this.enabled;
		}
	}

	function main() {
		// Get A WebGL context
		/** @type {HTMLCanvasElement} */
		var canvas = document.getElementById("canvas");
		var gl = canvas.getContext("webgl");
		if (!gl) {
			return;
		}
		gl.getExtension('OES_standard_derivatives');
		console.log(gl.getParameter(gl.VERSION));
		console.log(gl.getParameter(gl.SHADING_LANGUAGE_VERSION));
		console.log(gl.getParameter(gl.VENDOR));

		// setup GLSL program
		var programInfo = webglUtils.createProgramInfo(gl, ["3d-vertex-shader", "3d-fragment-shader"]);

		//objects = createObjects(gl,programInfo);
		scene = new Scene(gl,programInfo);
		scene.createObjects();

		requestAnimationFrame(render);

		// Draw the scene.
		function render(time) {
			var t = time /1000;

			webglUtils.resizeCanvasToDisplaySize(gl.canvas);

			// Tell WebGL how to convert from clip space to pixels
			gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

			gl.enable(gl.CULL_FACE);
			gl.enable(gl.DEPTH_TEST);

			// Clear the canvas AND the depth buffer.
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

			// Compute the projection matrix
			projectionMatrix = getProjectionMatrix(gl);
			
			// Compute the camera's matrix using look at.
			cameraMatrix = m4.lookAt(cameraPosition, target, up);

			// Make a view matrix from the camera matrix.
			viewMatrix = m4.inverse(cameraMatrix);

			// ------ Draw Objects --------
			if(!paused){
				scene.render(time);
			}

			requestAnimationFrame(render);
		}


		var getProjectionMatrix = function(gl){
			var ret = setViewPerspective(gl);
			var elPers = document.getElementById("perspective") ;
			var elOrtho = document.getElementById("ortho") ;

			if(view == viewTypes['Perspective']){
				ret = setViewPerspective(gl);
				elPers.classList.add("active");
				elOrtho.classList.remove("active");
			}else{
				ret = setViewOrtho(gl);
				elPers.classList.remove("active");
				elOrtho.classList.add("active");
			}

			return ret;
		}

		var setViewOrtho = function (gl) {
			var near = -1;
			var far = 10000;
			var radius = 1.0;

			var target_width = 120.0 * orthoscale;
			var target_height = 200.0 * orthoscale;

			var A = target_width / target_height; // target aspect ratio 
			var V = gl.canvas.clientWidth / gl.canvas.clientHeight;


			var mat = [];

			// calculate V as above
			if (V >= A) {
			    // wide viewport, use full height
			    mat = m4.orthographic(-V/A * target_width/2.0, V/A * target_width/2.0, -target_height/2.0, target_height/2.0,  near, far);
			} else {
			    // tall viewport, use full width
			    mat = m4.orthographic(-target_width/2.0, target_width/2.0, -A/V*target_height/2.0, A/V*target_height/2.0,  near, far);
			}

			return mat;
		}

		var setViewPerspective = function (gl) {
			var fieldOfViewRadians = degToRad(60);
			var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
			return m4.perspective(fieldOfViewRadians, aspect, 1, 2000);
		}
	
		var moveSpotLight = function (diffX, diffY) {
			var dir = [-cameraPosition[0]+target[0],
							-cameraPosition[1]+target[1],
							-cameraPosition[2]+target[2],
							0];

			var normDir = normalize(dir);

			var diff = [diffX,diffY];
			var dirInCamerCoor = normalize(vecMatProduct(normDir,cameraMatrix));

			var newDirInCamerCoor = rotateX([dirInCamerCoor[0],dirInCamerCoor[1],dirInCamerCoor[2]],diff[1]);
			var newDirInCamerCoor = rotateY([newDirInCamerCoor[0],newDirInCamerCoor[1],newDirInCamerCoor[2]],diff[0]);
			var newDir = normalize(vecMatProduct(newDirInCamerCoor,m4.inverse(cameraMatrix)));

			//console.log("CamerDir:",normDir);
			//console.log("dirInCamerCoor:",dirInCamerCoor);
			//console.log("diff:",diff);
			//console.log("CamerDir:",newDir);
			//console.log("===================================");

			lightDirection[4] = [newDir[0],newDir[1],newDir[2]];
			lightPosition[4] = [cameraPosition[0], cameraPosition[1], cameraPosition[2], 0.0] ;
		}
	
		document.onkeydown = function(e) {
			var dir = [-cameraPosition[0]+target[0],
							-cameraPosition[1]+target[1],
							-cameraPosition[2]+target[2],
							0];

			var normDir = normalize(dir);

			if (e.which >= '1'.charCodeAt(0) && e.which <= '9'.charCodeAt(0)){
				scene.toggleAnimation(e.which-48);
			}
			else if (e.which == 'W'.charCodeAt(0)){ // Forward
				cameraPosition = vecAdd(cameraPosition,normDir);
				target = vecAdd(target,normDir);
				orthoscale *= .99; 
				moveSpotLight(0,0);
			}
			else if (e.which == 'S'.charCodeAt(0)){ // Back
				cameraPosition = vecAdd(cameraPosition,multByScalar(normDir,-1));
				target = vecAdd(target,multByScalar(normDir,-1));
				orthoscale *= 1.01;
				moveSpotLight(0,0);
			}
			else if (e.which == 'A'.charCodeAt(0)){ // left
				var newDir = rotateY(normDir,-0.2);
				target = vecAdd(cameraPosition,newDir);
				moveSpotLight(0,0);
			}
			else if (e.which == 'D'.charCodeAt(0)){ // right
				var newDir = rotateY(normDir,0.2);
				target = vecAdd(cameraPosition,newDir);
				moveSpotLight(0,0);
			}
			else if (e.which == 'E'.charCodeAt(0)){ // up
				var dirInCamerCoor = normalize(vecMatProduct(normDir,cameraMatrix));
				var newDirInCamerCoor = normalize(rotateX([dirInCamerCoor[0],dirInCamerCoor[1],dirInCamerCoor[2]],-0.2));
				var newDir = normalize(vecMatProduct(newDirInCamerCoor,m4.inverse(cameraMatrix)));
				if(newDir[1]<0.8){
					target = vecAdd(cameraPosition,newDir);
				}
				moveSpotLight(0,0);
			}
			else if (e.which == 'Q'.charCodeAt(0)){ // down
				var dirInCamerCoor = normalize(vecMatProduct(normDir,cameraMatrix));
				var newDirInCamerCoor = normalize(rotateX([dirInCamerCoor[0],dirInCamerCoor[1],dirInCamerCoor[2]],0.2));
				var newDir = normalize(vecMatProduct(newDirInCamerCoor,m4.inverse(cameraMatrix)));
				if(newDir[1]>-0.8){
					target = vecAdd(cameraPosition,newDir);
				}
				moveSpotLight(0,0);
			}
			else if (e.which == 'O'.charCodeAt(0)){
				console.log('Orthographic');
				view = viewTypes['Orthographic'];
			}
			else if (e.which == 'P'.charCodeAt(0)){
				console.log('Perspective');
				view = viewTypes['Perspective'];
			}
			else if (e.which == 'X'.charCodeAt(0)){
				var dis = document.getElementById("sidebar").style.display ;
				document.getElementById("sidebar").style.display = dis != "none" ? "none":"block";
			}
			else if (e.which == 'M'.charCodeAt(0)){
				lightPosition[2][0] += 10;
			}
			else if (e.which == 'B'.charCodeAt(0)){
				lightPosition[2][0] -= 10;
			}
			else if (e.which == 'H'.charCodeAt(0)){
				lightPosition[2][1] += 10;
			}
			else if (e.which == 'N'.charCodeAt(0)){
				lightPosition[2][1] -= 10;
			}
			else if (e.which == 'J'.charCodeAt(0)){
				lightPosition[2][2] += 10;
				lightPosition[2][2] = Math.max(lightPosition[2][2],0);
			}
			else if (e.which == 'G'.charCodeAt(0)){
				lightPosition[2][2] -= 10;
				lightPosition[2][2] = Math.max(lightPosition[2][2],0);
			}
			else if (e.which == 'F'.charCodeAt(0)){
				shadingMode = (shadingMode+1)%3;
				var shadingSpans = document.getElementsByClassName("shading");
				for (let index = 0; index < shadingSpans.length; index++) {
					var element = shadingSpans[index];
					if(index == shadingMode){
						element.classList.add("active");
					} else{
						element.classList.remove("active");
					}
				}
			}
			else if (e.which == 'Z'.charCodeAt(0)){
				//lightPosition[0] = cameraPosition[0];
				//lightPosition[1] = cameraPosition[1];
				//lightPosition[2] = cameraPosition[2];
				console.log(cameraPosition,lightPosition);
			}
			else if(e.keyCode == 32){
				paused = !paused;
				var pause_screen = document.getElementById("pause-screen") ;

				if(paused){
					pause_screen.classList.remove("hidden");
				}else{
					pause_screen.classList.add("hidden");
				}
			}
			else if(e.keyCode == 38){
				spotlightInnerLimit = Math.max(0.4,spotlightInnerLimit-0.005)
				spotlightOuterLimit = Math.max(0.2,spotlightOuterLimit-0.005)
			}
			else if(e.keyCode == 40){
				spotlightInnerLimit = Math.min(0.999,spotlightInnerLimit+0.005)
				spotlightOuterLimit = Math.min(0.95,spotlightOuterLimit+0.005)
			}
		};

		document.onmousemove = function( event ) {
			moveSpotLight((event.pageX/gl.canvas.clientWidth - 0.5)*3.14/4, (event.pageY/gl.canvas.clientHeight-0.5)*3.14/4);
		};

		var updateLights = function () {
			lightSpecular = [multByScalar(lightColor[0], lightProperties[0][0]), multByScalar(lightColor[1], lightProperties[1][0]), multByScalar(lightColor[2], lightProperties[2][0]), multByScalar(lightColor[3], lightProperties[3][0]), multByScalar(lightColor[4], lightProperties[4][0])];
			lightDiffuse = [multByScalar(lightColor[0], lightProperties[0][1]), multByScalar(lightColor[1], lightProperties[1][1]), multByScalar(lightColor[2], lightProperties[2][1]), multByScalar(lightColor[3], lightProperties[3][1]), multByScalar(lightColor[4], lightProperties[4][1])];
			lightAmbient = [multByScalar(lightColor[0], lightProperties[0][2]), multByScalar(lightColor[1], lightProperties[1][2]), multByScalar(lightColor[2],lightProperties[2][2]), multByScalar(lightColor[3], lightProperties[3][2]), multByScalar(lightColor[4], lightProperties[4][2])];
		}
		
		var lightIntensitySliders = document.getElementsByClassName("lightIntensitySlider");
		var lightSelectionSlider = document.getElementById("light-selection-slider");
		var lightPropertiesSliders = document.getElementsByClassName("lightPropertiesSlider");
		var selectedLight = lightSelectionSlider.value;

		var updateLightProperties = function(){			
			var lightIndex = lightSelectionSlider.value;
			lightProperties[lightIndex][0] = document.getElementById("specular-intensity-slider").value;
			lightProperties[lightIndex][1] = document.getElementById("diffuse-intensity-slider").value;
			lightProperties[lightIndex][2] = document.getElementById("ambient-intensity-slider").value;
			lightColor[lightIndex][0] = document.getElementById("red-intensity-slider").value;
			lightColor[lightIndex][1] = document.getElementById("green-intensity-slider").value;
			lightColor[lightIndex][2] = document.getElementById("blue-intensity-slider").value;
			updateLights();
		}
		
		for (let index = 0; index < lightPropertiesSliders.length; index++) {
			lightPropertiesSliders[index].oninput = updateLightProperties;
		}

		var updateLightPropertiesSliders = function(lightIndex){
			document.getElementById("selected-light-label").textContent = document.getElementsByClassName("light-intensity-title")[lightIndex].textContent;
			document.getElementById("specular-intensity-slider").value = lightProperties[lightIndex][0];
			document.getElementById("diffuse-intensity-slider").value = lightProperties[lightIndex][1];
			document.getElementById("ambient-intensity-slider").value = lightProperties[lightIndex][2];
			document.getElementById("red-intensity-slider").value = lightColor[lightIndex][0];
			document.getElementById("green-intensity-slider").value = lightColor[lightIndex][1];
			document.getElementById("blue-intensity-slider").value = lightColor[lightIndex][2];
		}

		var selectedLightChanged = function() {
			var selectedLight = lightSelectionSlider.value;
			updateLightPropertiesSliders(selectedLight);
		}

		lightSelectionSlider.oninput = selectedLightChanged;

		selectedLightChanged();

		var lightIntensitySlidersChanged = function() {
			for (let index = 0; index < lightIntensitySliders.length; index++) {
				const element = lightIntensitySliders[index];
				lightColor[index] = multByScalar(lightColorBase[index], lightIntensitySliders[index].value);				
			}
			updateLights();
			selectedLightChanged();
		}
		
		for (let index = 0; index < lightIntensitySliders.length; index++) {
			lightIntensitySliders[index].oninput = lightIntensitySlidersChanged;
		}

		lightIntensitySlidersChanged();

		var shapeSelectionSlider = document.getElementById("shape-selection-slider");
		var matrialPropertiesSliders = document.getElementsByClassName("materialPropertySlider");
		var selectedShape = shapeSelectionSlider.value;
		
		var updateMaterialProperties = function(){			
			var shapeIndex = shapeSelectionSlider.value;
			scene.objects[shapeIndex].materialSpecular[0] = document.getElementById("specular-property-slider").value;
			scene.objects[shapeIndex].materialSpecular[1] = document.getElementById("specular-property-slider").value;
			scene.objects[shapeIndex].materialSpecular[2] = document.getElementById("specular-property-slider").value;
			scene.objects[shapeIndex].materialAmbient[0] = document.getElementById("diffuse-property-slider").value;
			scene.objects[shapeIndex].materialAmbient[1] = document.getElementById("diffuse-property-slider").value;
			scene.objects[shapeIndex].materialAmbient[2] = document.getElementById("diffuse-property-slider").value;
			scene.objects[shapeIndex].materialDiffuse[0] = document.getElementById("ambient-property-slider").value;
			scene.objects[shapeIndex].materialDiffuse[1] = document.getElementById("ambient-property-slider").value;
			scene.objects[shapeIndex].materialDiffuse[2] = document.getElementById("ambient-property-slider").value;
			scene.objects[shapeIndex].materialShininess = document.getElementById("shineness-property-slider").value;
			scene.objects[shapeIndex].color[0] = document.getElementById("red-property-slider").value;
			scene.objects[shapeIndex].color[1] = document.getElementById("green-property-slider").value;
			scene.objects[shapeIndex].color[2] = document.getElementById("blue-property-slider").value;
		}
		
		for (let index = 0; index < matrialPropertiesSliders.length; index++) {
			matrialPropertiesSliders[index].oninput = updateMaterialProperties;
		}

		var updateMaterialPropertiesSliders = function(shapeIndex){
			document.getElementById("selected-shape-label").textContent = scene.objects[shapeIndex].name;
			document.getElementById("specular-property-slider").value = scene.objects[shapeIndex].materialSpecular[0];
			document.getElementById("diffuse-property-slider").value = scene.objects[shapeIndex].materialAmbient[0];
			document.getElementById("ambient-property-slider").value = scene.objects[shapeIndex].materialDiffuse[0];
			document.getElementById("shineness-property-slider").value = scene.objects[shapeIndex].materialShininess;
			document.getElementById("red-property-slider").value = scene.objects[shapeIndex].color[0];
			document.getElementById("green-property-slider").value = scene.objects[shapeIndex].color[1];
			document.getElementById("blue-property-slider").value = scene.objects[shapeIndex].color[2];
		}

		var selectedShapeChanged = function() {
			var selectedShape = shapeSelectionSlider.value;
			updateMaterialPropertiesSliders(selectedShape);
		}
		
		shapeSelectionSlider.oninput = selectedShapeChanged;

		selectedShapeChanged();
		
		function indexInClass(collectionName, node) {
			var collection = document.getElementsByClassName(collectionName);
			for (var i = 0; i < collection.length; i++) {
				if (collection[i] === node)
				return i;
			}
			return -1;
		}
	}

	window.onload = main();

</script>
</body>
</html>